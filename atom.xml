<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tragic Master&#39;s Blog</title>
  
  
  <link href="https://jerry20000730.github.io/atom.xml" rel="self"/>
  
  <link href="https://jerry20000730.github.io/"/>
  <updated>2025-09-07T04:51:21.409Z</updated>
  <id>https://jerry20000730.github.io/</id>
  
  <author>
    <name>Tragic Master</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ECE 560 Computer and Information Security Homework 5</title>
    <link href="https://jerry20000730.github.io/wiki/duke-ece560-pdf-hw5/"/>
    <id>https://jerry20000730.github.io/wiki/duke-ece560-pdf-hw5/</id>
    <published>2025-09-07T04:50:52.010Z</published>
    <updated>2025-09-07T04:51:21.409Z</updated>
    
    <content type="html"><![CDATA[<embed src="./hw5.pdf" width="100%" height="750" type="application/pdf">]]></content>
    
    
    <summary type="html">Read each question carefully and be sure to answer all parts. Some questions are a mix of explanation and questions, so pay close attention to where you are being asked for something.</summary>
    
    
    
    <category term="ECE560" scheme="https://jerry20000730.github.io/categories/ECE560/"/>
    
    
    <category term="ECE560" scheme="https://jerry20000730.github.io/tags/ECE560/"/>
    
  </entry>
  
  <entry>
    <title>ECE 560 Computer and Information Security Homework 4</title>
    <link href="https://jerry20000730.github.io/wiki/duke-ece560-pdf-hw4/"/>
    <id>https://jerry20000730.github.io/wiki/duke-ece560-pdf-hw4/</id>
    <published>2025-09-07T04:49:16.342Z</published>
    <updated>2025-09-07T04:50:02.668Z</updated>
    
    <content type="html"><![CDATA[<embed src="./hw4.pdf" width="100%" height="750" type="application/pdf">]]></content>
    
    
    <summary type="html">Read each question carefully and be sure to answer all parts. Some questions are a mix of explanation and questions, so pay close attention to where you are being asked for something.</summary>
    
    
    
    <category term="ECE560" scheme="https://jerry20000730.github.io/categories/ECE560/"/>
    
    
    <category term="ECE560" scheme="https://jerry20000730.github.io/tags/ECE560/"/>
    
  </entry>
  
  <entry>
    <title>ECE 560 Computer and Information Security Homework 3</title>
    <link href="https://jerry20000730.github.io/wiki/duke-ece560-pdf-hw3/"/>
    <id>https://jerry20000730.github.io/wiki/duke-ece560-pdf-hw3/</id>
    <published>2025-09-07T04:47:21.794Z</published>
    <updated>2025-09-07T04:49:16.342Z</updated>
    
    <content type="html"><![CDATA[<embed src="./hw3.pdf" width="100%" height="750" type="application/pdf">]]></content>
    
    
    <summary type="html">Read each question carefully and be sure to answer all parts. Some questions are a mix of explanation and questions, so pay close attention to where you are being asked for something.</summary>
    
    
    
    <category term="ECE560" scheme="https://jerry20000730.github.io/categories/ECE560/"/>
    
    
    <category term="ECE560" scheme="https://jerry20000730.github.io/tags/ECE560/"/>
    
  </entry>
  
  <entry>
    <title>ECE 560 Computer and Information Security Homework 2</title>
    <link href="https://jerry20000730.github.io/wiki/duke-ece560-pdf-hw2/"/>
    <id>https://jerry20000730.github.io/wiki/duke-ece560-pdf-hw2/</id>
    <published>2025-09-07T04:43:19.511Z</published>
    <updated>2025-09-07T04:48:54.456Z</updated>
    
    <content type="html"><![CDATA[<embed src="./hw2.pdf" width="100%" height="750" type="application/pdf">]]></content>
    
    
    <summary type="html">Read each question carefully and be sure to answer all parts. Some questions are a mix of explanation and questions, so pay close attention to where you are being asked for something.</summary>
    
    
    
    <category term="ECE560" scheme="https://jerry20000730.github.io/categories/ECE560/"/>
    
    
    <category term="ECE560" scheme="https://jerry20000730.github.io/tags/ECE560/"/>
    
  </entry>
  
  <entry>
    <title>ECE 560 Computer and Information Security Homework 1</title>
    <link href="https://jerry20000730.github.io/wiki/duke-ece560-pdf-hw1/"/>
    <id>https://jerry20000730.github.io/wiki/duke-ece560-pdf-hw1/</id>
    <published>2025-09-01T15:04:49.921Z</published>
    <updated>2025-09-07T04:48:58.789Z</updated>
    
    <content type="html"><![CDATA[<embed src="./hw1.pdf" width="100%" height="750" type="application/pdf">]]></content>
    
    
    <summary type="html">Read each question carefully and be sure to answer all parts. Some questions are a mix of explanation and questions, so pay close attention to where you are being asked for something.</summary>
    
    
    
    <category term="ECE560" scheme="https://jerry20000730.github.io/categories/ECE560/"/>
    
    
    <category term="ECE560" scheme="https://jerry20000730.github.io/tags/ECE560/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.5840 Distributed System Lab1 MapReduce</title>
    <link href="https://jerry20000730.github.io/wiki/mit5840/lab1/"/>
    <id>https://jerry20000730.github.io/wiki/mit5840/lab1/</id>
    <published>2025-07-13T13:32:46.325Z</published>
    <updated>2025-07-13T13:36:14.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="intro">Intro</h1><p>实验是实现一个简单版本的MapReduce系统</p>]]></content>
    
    
    <summary type="html">MIT 6.5840 分布式系统 Lab1 实现MapReduce 代码实现记录</summary>
    
    
    
    <category term="名校课程" scheme="https://jerry20000730.github.io/categories/%E5%90%8D%E6%A0%A1%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="Distributed System" scheme="https://jerry20000730.github.io/tags/Distributed-System/"/>
    
  </entry>
  
  <entry>
    <title>Docker Hub 镜像命名规则</title>
    <link href="https://jerry20000730.github.io/wiki/Cloud-Native/docker2/"/>
    <id>https://jerry20000730.github.io/wiki/Cloud-Native/docker2/</id>
    <published>2025-04-26T15:23:36.357Z</published>
    <updated>2025-04-26T16:17:02.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker-hub上的镜像命名规则是什么">DockerHub上的镜像命名规则是什么</h1><p>镜像会分版本，虽然直接使用latest固然方便，但是在生产环境不可以这么做，会导致版本不可控（版本太重要了）。</p><p>通常来说，镜像标签的格式是<strong>应用的版本号+操作系统</strong>，其中版本号为<strong>主版本号+次版本号+补丁号</strong>，有的还会再正式发布前出rc版本（releasecandidate）。</p><p>有的标签还会加上<code>slim</code>，<code>fat</code>来进一步表示这个镜像的内容是经过精简的，还是包含了比较多的辅助工具，通常<code>slim</code>镜像会比较小，运行效率高，而<code>fat</code>镜像会比较大，适合用来进行开发调试。</p><blockquote><p>胖容器 和 瘦容器 胖容器 = “一锅端”打进去的操作系统 + 运行时 +应用，可立即跑，体积大、攻击面广、更新重。 瘦容器 =仅保留跑起来必需的内容，多阶段 / distroless制作，体积小、安全、传输快，但打包和排错更精细。</p></blockquote><h1 id="如何上传自己的镜像">如何上传自己的镜像</h1><ol type="1"><li>Docker Hub上注册一个用户</li><li>在本机上使用<code>docker login</code>功能，用注册的用户名和密码认证身份登录</li><li>【重要】<code>docker tag</code>命令，给镜像改成带用户名的完整名字，表示镜像是属于这个用户的，或者你直接在<code>docker build -t</code>在创建镜像的时候就起好名字</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag ngx-app tragicmaster/ngx-app:1.0</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>docker push</li></ol><h1 id="离线环境该怎么办">离线环境该怎么办</h1><p>使用DockerHub来管理镜像是非常方便，但是企业内网的离线环境，自然也就不能用<code>docker push</code>，<code>docker pull</code>来推送</p><p>最佳的方法是在内网环境里伪造DockerHub，创建一个自己私有的Registry服务，就像自己搭一个Github一样，目前自建Registry有很多成熟的解决方案，比如DockerRegistry，CNCF Harbor，腾讯内部使用的是Docker Registry。</p>]]></content>
    
    
    <summary type="html">官方认证的镜像或者是自己上传的镜像，这些命名规则有什么规律？</summary>
    
    
    
    <category term="Cloud-Native" scheme="https://jerry20000730.github.io/categories/Cloud-Native/"/>
    
    
    <category term="Docker" scheme="https://jerry20000730.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 镜像和 DockerFile</title>
    <link href="https://jerry20000730.github.io/wiki/Cloud-Native/docker1/"/>
    <id>https://jerry20000730.github.io/wiki/Cloud-Native/docker1/</id>
    <published>2025-04-26T13:54:33.980Z</published>
    <updated>2025-04-26T16:25:10.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="镜像的内部机制">镜像的内部机制</h2><p>镜像本质是一个打包文件，里面包含了应用程序还有它运行所依赖的环境，例如<strong>文件系统</strong>，<strong>环境变量</strong>，<strong>配置参数</strong>等。环境变量和配置参数相对比较简单，<em>真正麻烦的是<strong>文件系统</strong></em>。为了保证容器运行环境的一致性，镜像必须把应用程序锁在操作系统的根目录都包含进来，虽然这些文件里不包含kernel（容器共享宿主机kernel），但是如果每个镜像都重复做这样的打包操作，会有大量的冗余。</p><p>很自然的，我们就会想到将重复的部分抽取出来，存放一份根目录文件（比如Ubuntu），然后让所有镜像以某种方式共享这部分数据，这种方式就是分层（Layer）</p><p>容器的内部是由多个镜像层组成的，每层都是只读不可修改的一组文件，相同的层可以在镜像之间共享，然后多个层像搭积木一样堆叠起来，再使用一种叫做“联合文件系统（UnionFS）“的方式将他们合并在一起，就形成了容器最终看到的文件系统。</p><blockquote><p>联合文件系统（Union File System，UnionFs）可以将不同物理位置的目录合并、挂载到同一个目录中，即便目录的物理位置是分开的。UnionFs把文件系统的每一次修改作为一个个层进行叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。如果一次同时加载多个文件系统，UnionFs会把各层文件叠加起来，最终文件系统会包含所有底层文件和目录，从外部视角看，就是一个完成的文件系统。</p></blockquote><blockquote><p>容器镜像设计中，为了解决各类依赖以及依赖共享，正是利用 UnionFs实现了镜像分层，再结合bootfs、rootfs，一层层继承、叠加。启动容器时把相关的层挂载到一个目录，作为容器的根文件系统，这就是容器镜像的原理。</p></blockquote><p>使用命令<code>docker inspect</code>可以查看镜像的分层信息，比如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect nginx:alpine</span><br></pre></td></tr></table></figure><p>可以看到他的分层信息在"RootFS"的部分</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;RootFS&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;layers&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Layers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;sha256:a16e98724c05975ee8c40d8fe389c3481373d34ab20a1cf52ea2accc43f71f4c&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sha256:2daa38453f3839c68c18e7af10f04bf2259d432c05dce454841e24a129b53009&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sha256:d4261a1a67711866f8c31560e2326a631464f86c0a711c843cf6026dece885e8&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sha256:7d5d0920762752b29bf4329267456cad14f3ee902ef40179eb466c7a4eeaf4e7&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sha256:b4896f69ba7afecb40f6badf4287761288eab9952c7132ab900098fb2f28c16d&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sha256:61b204e6ce207d2ef4ed25e628fb08eaa1326173b78a218164d70d353cac9438&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sha256:1b69eff9b9cc79db4b61e434fe73334618dc3b7077fb9eb095db31b278a768ef&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sha256:60841a212b982e785aa9aa5aa7e7eea1128e7143829dd0b9ab3cd481f27d5e3d&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sha256:43628cfc79f5984e0a5287e2855b2131b3597c3dac57cc4525fefc2cf0052d7d&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>通过这个信息可以看出，nginx:alpine镜像由8个layer，所以你在使用<code>docker pull</code>的时候那些奇怪的输出信息是啥了</p><h2 id="dockerfile是什么">Dockerfile是什么</h2><p>知道了容器内部的结构和基本原理，就可以学习如何自己动手制作镜像了，也就是自己打包应用。如果我么将容器看成”现房“，镜像就是”样板间“，那么造出这个样板间我们需要”施工图纸“，施工图纸就是<strong>Dockerfile</strong></p><p>假设我们有一个Dockerfile:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">CMD echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>那么这个文件里只有两个指令，第一条指令是FROM，所有的Dockerfile都要从他开始，表示构建使用的基础镜像。第二条指令是CMD，它指定<code>docker run</code>启动容器时默认执行的命令。有了”施工图纸“，就可以使用<code>docker build</code>命令创建出镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker build -f Dockerfile.busybox .</span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon 7.68kB</span><br><span class="line">Step 1/2 : FROM busybox</span><br><span class="line"> ---&gt; d38589532d97</span><br><span class="line">Step 2/2 : CMD echo &quot;hello world&quot;</span><br><span class="line"> ---&gt; Running in c5a762edd1c8</span><br><span class="line">Removing intermediate container c5a762edd1c8</span><br><span class="line"> ---&gt; b61882f42db7</span><br><span class="line">Successfully built b61882f42db7</span><br></pre></td></tr></table></figure><p>其中<code>-f</code>参数指定Dockerfile文件名，后面必须跟一个文件路径，称为<strong>构建上下文（buildcontext）</strong></p><p>从命令输出也能看出，<code>docker build</code>不是在本地运行的，而是将所有的目录和运行环境打包传给远端，通过Dockerdaemon进行拉取镜像，打包，包装到容器中，参考下面这张图：</p><figure><img src="/images/CloudNative/docker/docker_principle.png"alt="docker principle" /><figcaption aria-hidden="true">docker principle</figcaption></figure><p>注意：使用上下文查找文件只能查找一级，不能递归向下查找第二级，比如：</p><figure><img src="/images/CloudNative/docker/example.png"alt="example file structure" /><figcaption aria-hidden="true">example file structure</figcaption></figure><p>如果指定路径为.，也就是当前路径，那么如果我想执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY hello.txt .</span><br></pre></td></tr></table></figure><p>就会报错，因为<code>hello.txt</code>在<code>docker</code>文件夹下面，不在helloworld-app的文件下，但是上下文只会查询一级，不会向下查询第二级。</p>]]></content>
    
    
    <summary type="html">镜像的本质是一层又一层的镜像层组成的，每层都是制度不可修改的一组文件</summary>
    
    
    
    <category term="Cloud-Native" scheme="https://jerry20000730.github.io/categories/Cloud-Native/"/>
    
    
    <category term="Docker" scheme="https://jerry20000730.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Go Programming Languages - 框架篇 - 日志 - Zap</title>
    <link href="https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_framework_log2/"/>
    <id>https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_framework_log2/</id>
    <published>2025-03-29T15:42:48.092Z</published>
    <updated>2025-04-13T15:21:16.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zap">Zap</h1><p>zap是uber开发的一个日志框架，相较于logrus来说，性能要好一些，公司内部也会用zap来进行日志的格式规范。</p><h1 id="类型">类型</h1><p>zap内置三种logger，对于<code>NewProduction</code>生产环境中运用的logger，会设置日志级别为info（意味着debugger不会被输出），error及error以上会打印调用堆栈，会上报位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logger := zap.NewExample() <span class="comment">// 测试</span></span><br><span class="line">logger := zap.NewDevelopment() <span class="comment">// 开发环境</span></span><br><span class="line">logger, _ := zap.NewProduction()</span><br></pre></td></tr></table></figure><p>zap的性能之所以比较好，很大一部分原因是因为日志里面需要显式地声明数据的类型，比如<code>zap.Int</code>，<code>zap.Namespace</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logger.Debug(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">logger.Info(<span class="string">&quot;hello&quot;</span>, zap.Int(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>))</span><br><span class="line">logger.Error(<span class="string">&quot;hello&quot;</span>, zap.Namespace(<span class="string">&quot;china&quot;</span>), zap.Int(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>))</span><br></pre></td></tr></table></figure><p>一般来说，不需要定制log的，直接使用<code>logger := zap.NewDevelopment()</code>或<code>logger, _ := zap.NewProduction()</code>即可，但如果需要定制部分功能的，需要灵活操作的，则可以使用<code>logger.New()</code>进行定制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.OpenFile(logFile, os.O_CREATE|os.O_APPEND|os.O_WRONLY, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">encoderConfig := zap.NewProductionEncoderConfig()</span><br><span class="line">encoderConfig.EncodeTime = zapcore.TimeEncoderOfLayout(<span class="string">&quot;2006-01-02 15:04:05.000&quot;</span>) <span class="comment">// 指定时间格式，不是时间戳</span></span><br><span class="line"><span class="comment">// &#123;&quot;level&quot;:&quot;info&quot;,&quot;ts&quot;:1744551191.6673155,&quot;caller&quot;:&quot;io/zap_test.go:13&quot;,&quot;msg&quot;:&quot;hello&quot;,&quot;age&quot;:18&#125;</span></span><br><span class="line"><span class="comment">// ts 换成 time</span></span><br><span class="line">encoderConfig.TimeKey = <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// level的显示样式为大写</span></span><br><span class="line">encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder</span><br><span class="line"></span><br><span class="line">core := zapcore.NewCore(</span><br><span class="line">    <span class="comment">// zapcore.NewJSONEncoder(encoderConfig)</span></span><br><span class="line">    zapcore.NewConsoleEncoder(encoderConfig),</span><br><span class="line">    zapcore.AddSync(file),</span><br><span class="line">    zapcore.InfoLevel,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">logger := zap.New(</span><br><span class="line">    core,</span><br><span class="line">    zap.AddCaller(),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> logger</span><br></pre></td></tr></table></figure><p>也可以使用第三方日志轮询库，如之前提到的<code>rotatelogs</code>或者<code>lumberjack</code>(<ahref="https://github.com/natefinch/lumberjack.git">https://github.com/natefinch/lumberjack.git</a>)</p><p>zap与logrus一样，可以添加<strong>钩子</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logger := zap.New(</span><br><span class="line">    core,</span><br><span class="line">    zap.AddCaller(),</span><br><span class="line">    zap.AddStacktrace(zapcore.ErrorLevel),</span><br><span class="line">    zap.Hooks(<span class="function"><span class="keyword">func</span><span class="params">(e zapcore.Entry)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e.Level &gt;= zapcore.ErrorLevel &#123;</span><br><span class="line">            fmt.Println(e.Message)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上述代码在error级别及以上的日志可以在终端中打印错误的message，比如<code>logger.Error("hello", zap.Namespace("china"), zap.Int("age", 18))</code>则会打印<code>hello</code>。<code>zap.AddStacktrace(zapcore.ErrorLevel)</code>允许在errorlevel及其以上打印调用堆栈</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2025-04-13 23:03:20.000ERRORio/zap_test.go:22hello&#123;&quot;china&quot;: &#123;&quot;age&quot;: 18&#125;&#125;</span><br><span class="line">github.com/Jerry20000730/go-framework/io.TestZap2</span><br><span class="line">/home/guofangcheng/go-framework/io/zap_test.go:22</span><br><span class="line">testing.tRunner</span><br><span class="line">/usr/local/go/src/testing/testing.go:1792</span><br></pre></td></tr></table></figure><p>如果需要公共的field，可以使用<code>logger.With</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logger = logger.With(</span><br><span class="line">    zap.Namespace(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">    zap.String(<span class="string">&quot;T-uuid&quot;</span>, uuid.New().String())</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>打印出来的公共参数：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2025-04-13 23:09:44.954INFOio/zap_test.go:21hello&#123;&quot;system&quot;: &#123;&quot;T-uuid&quot;: &quot;091dfb4e-c6a3-463e-9dd0-67c02521c7ee&quot;, &quot;age&quot;: 18&#125;&#125;</span><br><span class="line">2025-04-13 23:09:44.954ERRORio/zap_test.go:22hello&#123;&quot;system&quot;: &#123;&quot;T-uuid&quot;: &quot;091dfb4e-c6a3-463e-9dd0-67c02521c7ee&quot;, &quot;china&quot;: &#123;&quot;age&quot;: 18&#125;&#125;&#125;</span><br><span class="line">github.com/Jerry20000730/go-framework/io.TestZap2</span><br><span class="line">/home/guofangcheng/go-framework/io/zap_test.go:22</span><br><span class="line">testing.tRunner</span><br><span class="line">/usr/local/go/src/testing/testing.go:1792</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Go常用日志框架 - zap</summary>
    
    
    
    <category term="Programming Languages" scheme="https://jerry20000730.github.io/categories/Programming-Languages/"/>
    
    
    <category term="Go" scheme="https://jerry20000730.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go Programming Languages - 框架篇 - 日志 - Logrus</title>
    <link href="https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_framework_log/"/>
    <id>https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_framework_log/</id>
    <published>2025-03-19T15:36:00.651Z</published>
    <updated>2025-03-29T16:44:59.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日志作用">日志作用</h1><ol type="1"><li>定位问题 -这个就不用多说了，平常排查问题用的最多的方法就是看日志</li><li>监控 - 这个没咋用过，留个空</li><li>业务分析 - 统计数据吧，比如有多少请求，多少次I/O请求啥的</li></ol><h1id="日志级别程度由低到高大体上是这个顺序">日志级别(程度由低到高，大体上是这个顺序)</h1><ul><li>DEBUG</li><li>INFO</li><li>WARN</li><li>ERROR</li><li>FATAL</li></ul><h1 id="logrus介绍">Logrus介绍</h1><p><ahref="https://github.com/sirupsen/logrus">https://github.com/sirupsen/logrus</a></p><p>根据github介绍，logrus的定义是</p><blockquote><p>Logrus is a structured logger for Go (golang), completely APIcompatible with the standard library logger.</p></blockquote><p>logrus完全兼容标准的log库，还支持文本、JSON 两种日志输出格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/sirupsen/logrus</span><br></pre></td></tr></table></figure><h2 id="指定输出格式">指定输出格式</h2><p><strong>文本</strong>输出格式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logger.SetFormatter(&amp;logrus.TextFormatter&#123;</span><br><span class="line">    DisableColors: <span class="literal">true</span>, <span class="comment">// 强制不显示颜色</span></span><br><span class="line">    TimestampFormat: <span class="string">&quot;2006-01-02 15:04:05.000&quot;</span>,<span class="comment">// 显示ms</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>JSON</strong>输出格式 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logger.SetFormatter(&amp;logrus.JSONFormatter&#123;</span><br><span class="line">    TimestampFormat: <span class="string">&quot;2006-01-02 15:04:05.000&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这个包的问题：不会进行日志轮询，即定期进行清理，避免log文件不断大下去</p><p>有一个包叫rotatelogs，但已经不维护了</p><h2 id="rotatelogs介绍">rotatelogs介绍</h2><p><ahref="https://github.com/lestrrat-go/file-rotatelogs">https://github.com/lestrrat-go/file-rotatelogs</a></p><p>根据定义，rotatelogs的作用是</p><blockquote><p>Provide an io.Writer that periodically rotates log files from withinthe application</p></blockquote><p>也就是说在应用程序内定期轮换日志文件</p><p><strong>安装命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/lestrrat-go/file-rotatelogs</span><br></pre></td></tr></table></figure><p>rotatelogs可以指定：</p><ol type="1"><li>日志名格式</li><li>软链接</li><li>每隔多少时间生成一份日志</li><li>最大保存期限</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fout, err := rotatelogs.New(</span><br><span class="line">    logFilePath+<span class="string">&quot;.%Y%m%d%H&quot;</span>,                  <span class="comment">// 指定日志文件的路径和名称，路径不存在的时候会创建</span></span><br><span class="line">    rotatelogs.WithLinkName(logFilePath),     <span class="comment">// 为最新的一份日志创建软链接</span></span><br><span class="line">    rotatelogs.WithRotationTime(<span class="number">1</span>*time.Hour), <span class="comment">// 每隔1小时生成一份新的日志文件</span></span><br><span class="line">    rotatelogs.WithMaxAge(<span class="number">7</span>*<span class="number">24</span>*time.Hour),    <span class="comment">// 只留最近7天的日志，或使用WithRotationCount，表示只保留最近的几份日志</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>设置日志输出方式</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置为日志文件输出</span></span><br><span class="line">logger.SetOutput(fout)</span><br><span class="line"><span class="comment">// 设置为终端输出</span></span><br><span class="line">logger.SetOutput(os.Stdout)</span><br><span class="line"><span class="comment">// 设置为不输出</span></span><br><span class="line">log.SetOutput(ioutil.Discard)</span><br></pre></td></tr></table></figure><p><strong>设置日志调用关系</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.SetReportCaller(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>这样输出的日志就会带上method，比如： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;animal&quot;</span><span class="punctuation">:</span><span class="string">&quot;penguin&quot;</span><span class="punctuation">,</span><span class="attr">&quot;level&quot;</span><span class="punctuation">:</span><span class="string">&quot;fatal&quot;</span><span class="punctuation">,</span><span class="attr">&quot;method&quot;</span><span class="punctuation">:</span><span class="string">&quot;github.com/sirupsen/arcticcreatures.migrate&quot;</span><span class="punctuation">,</span><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;a penguin swims by&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span><span class="string">&quot;2014-03-10 19:57:38.562543129 -0400 EDT&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><p><strong>钩子（Hooks）</strong></p><p>简单来说就是打印日志的时候顺带会执行的操作，比如发短信啦，接入一些平台bot发消息啦</p><p>logrus支持hooks请参考官网：<ahref="https://github.com/sirupsen/logrus/wiki/Hooks">https://github.com/sirupsen/logrus/wiki/Hooks</a></p><p><strong>自定义钩子</strong>实现hook的两个方法，一个是<code>Levels</code>，表示适用于哪些等级，另一个是<code>Fire</code>，表示具体做法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现logurs.Hook接口</span></span><br><span class="line"><span class="keyword">type</span> AppHook <span class="keyword">struct</span> &#123;</span><br><span class="line">AppName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适用于哪些Level</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *AppHook)</span></span> Levels() []logrus.Level &#123;</span><br><span class="line"><span class="keyword">return</span> []logrus.Level&#123;logrus.ErrorLevel, logrus.FatalLevel, logrus.PanicLevel&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Fire函数时可读取或修改logrus.Entry</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *AppHook)</span></span> Fire(entry *logrus.Entry) <span class="type">error</span> &#123;</span><br><span class="line">entry.Data[<span class="string">&quot;app&quot;</span>] = h.AppName</span><br><span class="line">    <span class="comment">// 这里你可以将Error Fatal 和 Panic级别的错误日志发送到kafka</span></span><br><span class="line">fmt.Println(entry.Message)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中Entry的结构是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Entry <span class="keyword">struct</span> &#123;</span><br><span class="line">Logger *Logger</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contains all the fields set by the user.</span></span><br><span class="line">Data Fields</span><br><span class="line"></span><br><span class="line"><span class="comment">// Time at which the log entry was created</span></span><br><span class="line">Time time.Time</span><br><span class="line"></span><br><span class="line"><span class="comment">// Level the log entry was logged at: Trace, Debug, Info, Warn, Error, Fatal or Panic</span></span><br><span class="line"><span class="comment">// This field will be set on entry firing and the value will be equal to the one in Logger struct field.</span></span><br><span class="line">Level Level</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calling method, with package name</span></span><br><span class="line">Caller *runtime.Frame</span><br><span class="line"></span><br><span class="line"><span class="comment">// Message passed to Trace, Debug, Info, Warn, Error, Fatal or Panic</span></span><br><span class="line">Message <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// When formatter is called in entry.log(), a Buffer may be set to entry</span></span><br><span class="line">Buffer *bytes.Buffer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contains the context set by the user. Useful for hook processing etc.</span></span><br><span class="line">Context context.Context</span><br><span class="line"></span><br><span class="line"><span class="comment">// err may contain a field formatting error</span></span><br><span class="line">err <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fields <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>对应生成的日志就是中的话，<code>Message</code>就是<code>msg</code>，<code>Level</code>就是<code>level</code>，实际存储在的是<code>Data</code>变量中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">,</span><span class="attr">&quot;file&quot;</span><span class="punctuation">:</span><span class="string">&quot;/home/guofangcheng/go-framework/io/logrus_test.go:14&quot;</span><span class="punctuation">,</span><span class="attr">&quot;func&quot;</span><span class="punctuation">:</span><span class="string">&quot;github.com/Jerry20000730/go-framework/io.TestLogrus&quot;</span><span class="punctuation">,</span><span class="attr">&quot;level&quot;</span><span class="punctuation">:</span><span class="string">&quot;info&quot;</span><span class="punctuation">,</span><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;this is info log&quot;</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;test&quot;</span><span class="punctuation">,</span><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span><span class="string">&quot;2025-03-24 01:03:48.080&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>示例代码就是做了个简单的处理，实际可以做更为复杂的逻辑，比如加入kafka，对接到提醒bot等。并且因为修改了<code>Data</code>，所以本质上可以修改他的日志输出内容。</p>]]></content>
    
    
    <summary type="html">Go常用日志框架 - logrus</summary>
    
    
    
    <category term="Programming Languages" scheme="https://jerry20000730.github.io/categories/Programming-Languages/"/>
    
    
    <category term="Go" scheme="https://jerry20000730.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go Programming Languages - Go Module Version</title>
    <link href="https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_module/"/>
    <id>https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_module/</id>
    <published>2025-03-11T15:48:09.849Z</published>
    <updated>2025-03-11T16:13:53.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go-module-版本规范">Go Module 版本规范</h1><ol type="1"><li>Go module每个版本以v开头，后面跟_语义版本_。当vcs为git时候，通常情况下模块的版本会是gittag的版本</li></ol><p><imgsrc="/images/ProgrammingLanguages/Go/go_module/module_version.png"alt="go module的版本号" /> <imgsrc="/images/ProgrammingLanguages/Go/go_module/git_version.png"alt="git tag版本" /></p><ol start="2" type="1"><li><p>当没有语义版本的时候，会生成一个伪版本，例如<code>v0.0.0-20190306012644-bacd9c7ef1dd</code>这种，其中第二部分代表代码生成的时间，第三部分是这个代码当前commit的id的前12个字符。（可以通过<code>git log</code>来查看）</p></li><li><p>主版本为2或更高版本的时候，go模块路径必须带有类似于<code>/v2</code>或<code>/v3</code>这样的主版本后缀，比如<code>github.com/gocolly/colly/v2</code>，<code>github.com/mailru/go-clickhouse/v2</code>，这就是为什么<code>go get</code>或<code>go install</code>的时候可以指定版本号，如：</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/cespare/xxhash@v1.1.0</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>主版本号不同表示不兼容，一个项目里可能同时依赖不同的主版本号，比如</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;gopkg.in/yaml.v2&quot;</span></span><br><span class="line">    yaml3 <span class="string">&quot;gopkg.in/yaml.v3&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li><p><code>go get -u</code>不会更新主版本号，即<code>-u</code>表示更新到当前主版本号下的最新版本</p></li><li><p>在使用gomodule规范之前，有些第三方库的高版本没有加<code>/v2</code>或<code>/v3</code>后缀，此时需要加incompatible，如<code>github/go-redis/redis v6.15.9+incompatible</code>路径没有<code>/v6</code>后缀</p></li><li><p>主版本后缀不允许有<code>/v0</code>或<code>/v1</code>出现</p><ol type="a"><li>一种特殊情况：以<code>gopkg.in/</code>开头的模块路径必须始终具有主版本后缀。后缀必须以点开头，而不是斜杠，例如<code>gopkg.in/check.v1</code>，<code>gopkg.in/yaml.v3</code></li></ol></li></ol>]]></content>
    
    
    <summary type="html">Go版本规范</summary>
    
    
    
    <category term="Programming Languages" scheme="https://jerry20000730.github.io/categories/Programming-Languages/"/>
    
    
    <category term="Go" scheme="https://jerry20000730.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go Programming Languages - Extra Settings</title>
    <link href="https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_extra/"/>
    <id>https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_extra/</id>
    <published>2025-03-08T12:14:25.550Z</published>
    <updated>2025-03-11T15:48:03.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go-module">Go module</h1><h2 id="go-module的原理">Go module的原理</h2><p>go module 根据官网定义</p><blockquote><p>A Go module is a collection of Go packages stored in a file tree witha go.mod file at its root</p></blockquote><p>在Go Module没有出现之前，所有依赖距均从<code>$GOPATH/src/</code> 或<code>$GOROOT/src/</code> 中进行查找导入，Go Modules是为了提升使用其他开发者代码，即添加<strong>依赖项（模块、包）</strong>时的体验，也是为了让代码的正确性、安全性得到保障。</p><p>在 Go 支持 Go Modules之后，编译时编译器会从工作目录（当前所在目录）开始并逐级向上查找是否具有go.mod 文件。</p><h2 id="如何开启">如何开启？</h2><p>用环境变量 GO111MODULE开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是 auto。</p><ul><li><code>GO111MODULE=off</code> 无模块支持，Go 会从 GOPATH 和 vendor文件夹寻找包。</li><li><code>GO111MODULE=on</code> 模块支持，Go 会忽略 GOPATH 和 vendor文件夹，只根据 go.mod 下载依赖。</li><li><code>GO111MODULE=auto</code> 在 <code>$GOPATH/src</code>外面且根目录有 go.mod 文件时，开启模块支持。</li></ul><p>注意：在使用模块的时候，GOPATH是无意义的，不过它还是会把下载的依赖储存在 <code>$GOPATH/src/mod</code>中，也会把 go install 的结果放在 <code>$GOPATH/bin</code> 中</p><h2 id="如何初始化一个module">如何初始化一个module</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init $&#123;module_name&#125;</span><br></pre></td></tr></table></figure><h2 id="go-module-名称">Go module 名称</h2><p>module名称有模块路径标识，模块路径就是模块的规范名称，为了规范，很多公司会将确保模块名称加上<code>https://</code>的前缀就是源码仓库的地址。</p><p>举例： <img src="/images/ProgrammingLanguages/Go/go_extra/module.png"alt="module名称与实际github地址相同" /></p><p>这样做的目的是为了方便其他公司/组织的人下载依赖时使用</p><p>注意： 1. 模块名可以不是源码仓库地址 2. 模块名称可以包含子目录</p><p>下面讨论如何下载，已经如果模块名称不为实际下载地址的时候Gomodule是如何解决的。</p><h2 id="如何下载go-module下载自己项目的依赖项">如何下载GoModule（下载自己项目的依赖项）？</h2><p>一般来说，只需要知道你需要下载的module名称即可，比如我需要下载上图testify的包，我只需要：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/stretchr/testify</span><br></pre></td></tr></table></figure><p>但有的时候，一些module的名称与源码仓库地址不一样，比如下图： <imgsrc="/images/ProgrammingLanguages/Go/go_extra/module2.png"alt="module名称与实际github地址不相同" /></p><p>当执行get命令的时候： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get go.uber.org/zap</span><br></pre></td></tr></table></figure></p><p>会先向https://go.uber.org/zap?go-get=1发送一个<code>GET</code>请求<img src="/images/ProgrammingLanguages/Go/go_extra/module3.png"alt="postman显示发送get请求后的响应体" /></p><p>此时，响应体里会有一个meta标签，name为<code>go-import</code>，对应的content由三部分组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 1. 模块名称</span><br><span class="line"># 2. 版本控制工具（git还是svn）</span><br><span class="line"># 3. 实际的源码仓库地址</span><br><span class="line">go.uber.org/zap git https://github.com/uber-go/zap</span><br></pre></td></tr></table></figure><h2id="如何下载模块中的子模块下载自己项目的依赖项中的其中一个模块">如何下载模块中的子模块（下载自己项目的依赖项中的其中一个模块）？</h2><p>假设我需要的不是<code>zap</code>这个项目的所有源码，而是其中一个模块，比如<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get go.uber.org/zap/tools</span><br></pre></td></tr></table></figure> 他的查找顺序如下： 1.先发送<code>GET</code>请求<code>https://go.uber.org/zap/tools?go-get=1</code>，发现查不到源码地址2. 再回溯一级目录，请求<code>https://go.uber/org/zap?go-get=1</code></p><h2 id="公司里面的做法">公司里面的做法</h2><ol type="1"><li>公司里面一般我们会直接<code>go get xxxx/repo.git</code>，这个时候就会直接克隆这个git地址的目录，无需再发送<code>go-get=1</code>的请求</li><li>一般来说，公司里面实际上会使用ssh的方式解决权限问题，比如使用git的时候我们会在$HOME/.gitconfig文件中追加<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[url &quot;ssh://git@xxx.com&quot;]</span><br><span class="line">    insteadOf = https://xxx.com</span><br></pre></td></tr></table></figure> 通过在git平台上传ssh公钥的方式解决权限问题</li></ol><h1 id="goproxy">GOPROXY</h1><h2 id="goproxy原理">GOPROXY原理</h2><p>几个问题： 1.互联网上的源码仓库除了github还有很多，在各种不同的网络环境下，如何保证下载速度？2. 默认情况下，goget不是直接去源码仓库上下载代码，而是通过代理<code>https://proxy.golang.org</code>(谷歌维护)去下载，代理对源码镜像进行了缓存并提供了CDN加速，但是源码更新几分钟后，代理里的镜像才会更新会有一定延迟。</p><p>国内代理有： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://goproxy.cn</span><br><span class="line">https://goproxy.io</span><br></pre></td></tr></table></figure></p><p>我们可以在GOPROXY环境变量下进行更改，以确保当谷歌的下载不下来的时候，可以使用国内代理下载。</p><h2 id="模块缓存">模块缓存</h2><p>下载的谋爱会保存在环境变量<code>GOMODCACHE</code>指定的目录下，默认为<code>$GOPATH/pkg/mod</code></p><h2 id="gosumdb">GOSUMDB</h2><p>sum.golang.org(由谷歌运行)提供了一个checksum数据库，用来存储源代码的哈希值，以防止goget从任何源头（包括代理）拉取了被篡改的源码。</p><ol type="1"><li>第一次用goget下载某个模块的时候，会计算其哈希值，与checksum数据库里的值进行对比，</li><li>如果一致，则把模块存入本地缓存目录，并将哈希值写入go.sum文件。后续使用该模块时通过go.sum文件来校验该模块自下载以来未曾被修改过。</li><li>如果设置环境变量<code>GOSUMDB=off</code>，或者goget的时候使用-insecure标志，标识不需要验证合法性。</li></ol><h2 id="如何使用公司内部私有的go-module">如何使用公司内部私有的Gomodule</h2><ol type="1"><li>GOPROXY的默认值（<code>https://proxy.golang.org,direct</code>），其中direct表示不走代理，直接从源码库下载（先发送go-get=1请求）</li><li>所有代理都不会访问私有仓库，所以goget私有模块的时候会命中direct，所有代理都不会访问私有仓库，所以goget私有模块的时候会命中direct。为避免下载私有模块的时候访问代理，可以把私有模块的前缀赋给<code>GONOPROXY</code>，如<code>GONOPROXY=xxx.xxx.com</code></li><li>私有模块不需要使用公共的checksum数据库，所以需要设置<code>GONOSUMDB=xxx.xxx.com</code></li><li>GOPRIVATE是<code>GONOPROXY</code>和<code>GONOSUMDB</code>的默认值，所以设置GOPRIVATE之后就不需要再设置<code>GONOPROXY</code>和<code>GONOSUMDB</code></li></ol><h2 id="如何部署公司私有的goproxy">如何部署公司私有的GOPROXY</h2><p><code>goproxy.io</code>除了提供国内可用的gomodule代理之外，还提供了部署私有go proxy的能力：</p><p><ahref="https://github.com/goproxyio/goproxy.git">https://github.com/goproxyio/goproxy.git</a></p><p>方法如下：</p><ol type="1"><li><p>编译安装go proxy <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/goproxyio/goproxy.git</span><br><span class="line">cd goproxy</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p></li><li><p>启动代码 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/goproxy -listen=0.0.0.0:80 -cacheDir=$HOME/go_module_cache -proxy https://goproxy.io -exclude &quot;gitlab.xxx.com&quot;</span><br></pre></td></tr></table></figure></p></li></ol><ul><li>其中 <code>-cacheDir</code>是代理使用的缓存目录，跟GOMODCACHE区分开，如果私有代理商找不到模块，就去访问公开代理（也就是https://goproxy.io）。</li><li><code>-proxy</code>指定公开代理</li><li><code>-exclude</code>指定那些模块直接去代码仓库下载</li><li>最后将自己的GOPROXY设置为<code>GOPROXY=xxx.com,direct</code>，xxx.com就是你服务器的域名，80端口开放</li></ul>]]></content>
    
    
    <summary type="html">Go需要知道的一些配置信息</summary>
    
    
    
    <category term="Programming Languages" scheme="https://jerry20000730.github.io/categories/Programming-Languages/"/>
    
    
    <category term="Go" scheme="https://jerry20000730.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>CICD流水线搭建流程 [GitLab + Ubuntu]</title>
    <link href="https://jerry20000730.github.io/wiki/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/CICD/"/>
    <id>https://jerry20000730.github.io/wiki/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/CICD/</id>
    <published>2024-10-27T21:51:49.000Z</published>
    <updated>2024-10-27T21:51:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="prerequisite">Prerequisite</h1><ol type="1"><li>GitLab 仓库</li><li>Ubuntu (18.04/20.04/22.04) 服务器</li><li>编程语言runtime</li></ol><h1 id="创建gitlab仓库">1. 创建GitLab仓库</h1><figure><img src="/images/CICD/gitlab-new-project.png"alt="create gitlab repo" /><figcaption aria-hidden="true">create gitlab repo</figcaption></figure><h1 id="创建gitlab-runner">2. 创建GitLab Runner</h1><p>服务器上先安装<code>gitlab-runner</code>服务 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gitlab-runner</span><br></pre></td></tr></table></figure></p><p>检查安装是否成功 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status gitlab-runner</span><br></pre></td></tr></table></figure></p><p>会显示 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">● gitlab-runner.service - GitLab Runner</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/gitlab-runner.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Mon 2020-06-01 09:01:49 UTC; 4s ago</span><br><span class="line"> Main PID: 16653 (gitlab-runner)</span><br><span class="line">    Tasks: 6 (limit: 1152)</span><br><span class="line">   CGroup: /system.slice/gitlab-runner.service</span><br><span class="line">           └─16653 /usr/lib/gitlab-runner/gitlab-runner run --working-directory /home/gitlab-runner --config /etc/gitlab</span><br></pre></td></tr></table></figure></p><p>其次在GitLab上进行绑定，进入仓库 - Settings - CICD - Runners</p><figure><img src="/images/CICD/gitlab-runner.png"alt="gitlab runner location" /><figcaption aria-hidden="true">gitlab runner location</figcaption></figure><p>点击 <code>New Project Runner</code>,然后写一下tag和description（确保你知道这个是那个服务器和干什么的），然后选中<code>Run untagged project</code>，确保你不会因为该项目没有tag而无法在runner上跑</p><figure><img src="/images/CICD/gitlab-runner-configure.png"alt="gitlab runner configure" /><figcaption aria-hidden="true">gitlab runner configure</figcaption></figure><h1 id="绑定gitlab-runner和服务器">3. 绑定gitlab-runner和服务器</h1><p>当 <code>gitlab-runner</code>注册之后，需要在服务器上进行token绑定</p><figure><img src="/images/CICD/new-runner-created.png"alt="gitlab runner binding" /><figcaption aria-hidden="true">gitlab runner binding</figcaption></figure><p>输入基础命令 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-runner register --url [project_URL] --token [runner_token]</span><br></pre></td></tr></table></figure> 然后可能会让你输入几个关键信息</p><ol type="1"><li>executor: 参照gitlab官方给出的<ahref="https://docs.gitlab.com/runner/executors/">executor类型</a>，我们因为是个小项目，暂时没有使用docker，所以选择shell</li><li>docker-image:如果选择docker作为executor的话，就会要求配置docker镜像</li><li>description: 描述一下 等信息，其它我没遇到，遇到了再记录</li></ol><h1 id="编写-.gitlab-ci.yml">4. 编写 <code>.gitlab-ci.yml</code></h1><p>首先是要填写流水线的阶段 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure></p><p>其次是各阶段所需要的命令和生成的文件单独列举出来，因为我们这个是个springboot项目，每次推送main分支之后就会进行maven编译，生成target文件夹下的jar包，然后在javaruntime运行，流水线思路简单。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mvn</span> <span class="string">clean</span> <span class="string">package</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">target/*.jar</span></span><br><span class="line">    <span class="attr">expire_in:</span> <span class="number">1</span> <span class="string">week</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mvn</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">$DEPLOY_PATH</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cp</span> <span class="string">target/$APP_NAME</span> <span class="string">$DEPLOY_PATH/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">      while pgrep -f &quot;$APP_NAME&quot; &gt; /dev/null; do</span></span><br><span class="line"><span class="string">        pkill -f &quot;$APP_NAME&quot;</span></span><br><span class="line"><span class="string">        sleep 1</span></span><br><span class="line"><span class="string">      done</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="string">nohup</span> <span class="string">java</span> <span class="string">-jar</span> <span class="string">$DEPLOY_PATH/$APP_NAME</span> <span class="string">--spring.profiles.active=prod</span> <span class="string">&gt;</span> <span class="string">$DEPLOY_PATH/app.log</span> <span class="number">2</span><span class="string">&gt;&amp;1</span> <span class="string">&amp;</span></span><br></pre></td></tr></table></figure><p>其中 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">  while pgrep -f &quot;$APP_NAME&quot; &gt; /dev/null; do</span></span><br><span class="line"><span class="string">    pkill -f &quot;$APP_NAME&quot;</span></span><br><span class="line"><span class="string">    sleep 1</span></span><br><span class="line"><span class="string">  done</span></span><br><span class="line"><span class="string"></span><span class="bullet">-</span> <span class="string">nohup</span> <span class="string">java</span> <span class="string">-jar</span> <span class="string">$DEPLOY_PATH/$APP_NAME</span> <span class="string">--spring.profiles.active=prod</span> <span class="string">&gt;</span> <span class="string">$DEPLOY_PATH/app.log</span> <span class="number">2</span><span class="string">&gt;&amp;1</span> <span class="string">&amp;</span></span><br></pre></td></tr></table></figure> 是为了保证能够确保关掉上一次跑的进程。</p><h1 id="reference">Reference</h1><ol type="1"><li>How To Set Up a Continuous Deployment Pipeline with GitLab CI/CD onUbuntu <ahref="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-continuous-deployment-pipeline-with-gitlab-on-ubuntu">https://www.digitalocean.com/community/tutorials/how-to-set-up-a-continuous-deployment-pipeline-with-gitlab-on-ubuntu</a></li><li>Use CI/CD to build your application <ahref="https://docs.gitlab.com/ee/topics/build_your_application.html">https://docs.gitlab.com/ee/topics/build_your_application.html</a></li></ol>]]></content>
    
    
    <summary type="html">记录一下在ubuntu服务器上搭建CICD (未使用Docker)</summary>
    
    
    
    <category term="环境配置" scheme="https://jerry20000730.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="CICD" scheme="https://jerry20000730.github.io/tags/CICD/"/>
    
  </entry>
  
  <entry>
    <title>部署SSL证书</title>
    <link href="https://jerry20000730.github.io/wiki/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/SSLBuild/"/>
    <id>https://jerry20000730.github.io/wiki/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/SSLBuild/</id>
    <published>2024-10-27T07:00:47.000Z</published>
    <updated>2024-10-27T07:00:47.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#prerequisite">Prerequisite</a></li><li><a href="#------------">申请免费证书 (腾讯云)</a></li><li><a href="#--ssl---nginx-">安装SSL证书（Nginx）</a><ul><li><a href="#--ssl--">下载SSL文件</a></li><li><a href="#-------">登录远程服务器</a></li></ul></li><li><a href="#reference">Reference</a></li></ul><!-- tocstop --><h1 id="prerequisite">Prerequisite</h1><ol type="1"><li>一个域名</li><li>Nginx服务器</li></ol><h1 id="申请免费证书-腾讯云">申请免费证书 (腾讯云)</h1><ol type="1"><li>登录 <a href="https://console.cloud.tencent.com/ssl">SSL证书控制台</a>，进入<strong>我的证书</strong>页面，并单击<strong>申请免费证书</strong>。</li><li>填写证书申请表单，如下图所示： <imgsrc="/images/SSL/free_certificate.png"alt="apply for free certificate at Tencent Cloud" /> 其中：</li></ol><ul><li>证书绑定域名：网站域名</li><li>域名验证方式：一般选手动就可以，然后到域名解析商配置一下，因为本人是腾讯云买的，就比较方便，只需要到<ahref="https://console.cloud.tencent.com/cns/domains">https://console.cloud.tencent.com/cns/domains</a><ul><li>详情参考：<ahref="https://cloud.tencent.com/document/product/400/54500">https://cloud.tencent.com/document/product/400/54500</a></li></ul></li><li>申请邮箱：请输入您的邮箱地址。</li><li>算法选择：RSA就行</li></ul><h1 id="安装ssl证书nginx">安装SSL证书（Nginx）</h1><p>以下针对于使用Nginx进行反向代理部署的服务器</p><h2 id="下载ssl文件">下载SSL文件</h2><p>等待审核通过之后，点击下载按钮并获取SSL证书 <imgsrc="/images/SSL/download_button.png" alt="click download" />依据不同云服务器商要求下载对应版本（我下的是Nginx版本） <imgsrc="/images/SSL/download_version.png"alt="choose SSL download version" /></p><p><strong>文件夹中会含有以下几个文件：</strong></p><p><strong>证书文件</strong>：xxx.crt 证书文件</p><p><strong>密钥文件</strong>：xxx.key 私钥文件</p><p><strong>CSR文件</strong>：xxx.csr 文件</p><p><strong>PEM文件</strong>: xxx.pem 文件</p><p>我们只需要<code>.crt</code>和<code>.key</code>文件即可</p><h2 id="登录远程服务器">登录远程服务器</h2><p>WinSCP/PuTTY/我喜欢用Termius</p><ol type="1"><li><p>将已获取到的 cloud.tencent.com_bundle.crt 证书文件和cloud.tencent.com.key 私钥文件从本地目录拷贝到轻量应用服务器 Nginx默认配置文件目录中</p></li><li><p>输入grep命令获取nginx配置目录（知道的略过这步）<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / | grep nginx.conf</span><br></pre></td></tr></table></figure></p></li><li><p>然后去配置文件<code>nginx.conf</code>或者<code>site-enabled/default</code>(我是后者)配置文件增加下列行数<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl default_server;</span><br><span class="line">    listen [::]:443 ssl default_server;</span><br><span class="line">    ssl_certificate cert/tragicmaster.website_bundle.crt;</span><br><span class="line">    ssl_certificate_key cert/tragicmaster.website.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>保存并使用以下命令检测nginx配置是否正确 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure> 如果返回<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br></pre></td></tr></table></figure> 然后重新加载nginx (非常重要！不然换证书的时候容易检测不到)<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></p></li><li><p>登录域名https://tragicmaster.website左上角成功变锁！</p></li></ol><h1 id="reference">Reference</h1><ol type="1"><li>Nginx服务器证书安装 <ahref="https://cloud.tencent.com/document/product/1207/47027">https://cloud.tencent.com/document/product/1207/47027</a></li><li>linux下查看nginx的安装路径 <ahref="https://blog.csdn.net/sinat_22387459/article/details/115007510">https://blog.csdn.net/sinat_22387459/article/details/115007510</a></li><li>Nginx 安装 SSL 配置 HTTPS超详细完整全过程 <ahref="https://developer.aliyun.com/article/761236">https://developer.aliyun.com/article/761236</a></li></ol>]]></content>
    
    
    <summary type="html">记录一下SSL证书配置（SSL Certificate Deployment）</summary>
    
    
    
    <category term="环境配置" scheme="https://jerry20000730.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="SSL" scheme="https://jerry20000730.github.io/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串问题的解法</title>
    <link href="https://jerry20000730.github.io/wiki/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/longest-palindrome/"/>
    <id>https://jerry20000730.github.io/wiki/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/longest-palindrome/</id>
    <published>2024-10-22T05:19:22.000Z</published>
    <updated>2024-10-22T05:19:22.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#----">问题分析</a></li><li><a href="#----">判断方法</a></li><li><a href="#------">中心拓展方法</a></li><li><a href="#--------">二维动态规划方法</a></li></ul><!-- tocstop --><h2 id="问题分析">问题分析</h2><p>力扣链接：<ahref="https://leetcode.cn/problems/longest-palindromic-substring/description">https://leetcode.cn/problems/longest-palindromic-substring/description</a></p><p>给你一个字符串<code>s</code>，找到<code>s</code>种最长的回文子串 例如<code>s = "babbad"</code> 的最长回文子串是<code>abba</code>，长度为4</p><h2 id="判断方法">判断方法</h2><p>从两边向中间，或者中间向两边拓展，不断比较头尾字符是否相同即可</p><h2 id="中心拓展方法">中心拓展方法</h2><p>思路：遍历每一个字符，向两百年拓展找到一起为中心的最长回文子串，所有找到的回文子串的最大长度即所求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        longest = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># odd</span></span><br><span class="line">            p = self.getPalindrome(s, i, i)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(p) &gt; <span class="built_in">len</span>(longest):</span><br><span class="line">                longest = p</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># even</span></span><br><span class="line">            p = self.getPalindrome(s, i, i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(p) &gt; <span class="built_in">len</span>(longest):</span><br><span class="line">                longest = p</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> longest</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span>, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s[left+<span class="number">1</span>:right]</span><br></pre></td></tr></table></figure><h2 id="二维动态规划方法">二维动态规划方法</h2><p>回文串两边加上两个相同字符，会变成一个新的回文串，建立二维数组dp，找出所有的回文子串，<code>dp[i][j]</code>记录子串i到j是否为回文串</p><ol type="1"><li>初始化dp数组，所有一个字母都是回文串，所以<code>dp[i][i] = True</code></li><li>得出递推关系：<ul><li>如果<code>s[i]</code>和<code>s[j]</code>相等，并且子串<code>dp[i+1][j-1] = True</code>，那么<code>dp[i][j]</code>也为true</li><li>不相等，直接False</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        memo = [[<span class="literal">None</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        max_length = <span class="number">1</span></span><br><span class="line">        longest_start = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">i, j</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> max_length, longest_start, memo</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> memo[i][j] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> memo[i][j]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> dp(i+<span class="number">1</span>, j-<span class="number">1</span>):</span><br><span class="line">                memo[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> j-i+<span class="number">1</span> &gt; max_length:</span><br><span class="line">                    max_length = j-i+<span class="number">1</span></span><br><span class="line">                    longest_start = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                memo[i][j] = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> memo[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                dp(i, j)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s[longest_start:longest_start+max_length]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文记录最长回文子串问题的几种解决方法</summary>
    
    
    
    <category term="Algorithm" scheme="https://jerry20000730.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://jerry20000730.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Go Programming Languages - Goroutines</title>
    <link href="https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_goroutine/"/>
    <id>https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_goroutine/</id>
    <published>2024-09-03T13:21:01.000Z</published>
    <updated>2024-09-03T13:21:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="how-to-write-goroutine">How to write Goroutine</h2><p>任何函数只需加上<code>go</code>就能送给调度器运行，不需要像python,js一样区分是否为异步函数。</p><p>Very basic Goroutine usage: <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;hello from goroutine %d\n&quot;</span>, i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意 不能这么写 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;hello from goroutine %d\n&quot;</span>, i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 因为循环变量并不支持被延迟/动态计算</p><h2 id="what-is-co-routine-协程">What is Co-routine (协程)</h2><ul><li>lightweight thread (轻量级线程)</li><li>编译器/解释器/虚拟机层面的多任务</li><li>多个协程可能在一个或多个线程上运行</li><li>子程序（Subroutines）是协程的特例，协程更加广泛</li></ul><h2 id="goroutine可能得切换点">Goroutine可能得切换点</h2><ul><li>I/O, select</li><li>channel</li><li>等待锁</li><li><code>runtime.Gosched()</code></li></ul>]]></content>
    
    
    <summary type="html">A goroutine is a lightweight thread managed by Go runtime</summary>
    
    
    
    <category term="Programming Languages" scheme="https://jerry20000730.github.io/categories/Programming-Languages/"/>
    
    
    <category term="Go" scheme="https://jerry20000730.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go Programming Languages - Functional Programming</title>
    <link href="https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_lambda/"/>
    <id>https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_lambda/</id>
    <published>2024-09-03T12:46:13.000Z</published>
    <updated>2024-09-03T12:46:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="functional-programming-in-go-closure-闭包">FunctionalProgramming in GO: Closure (闭包)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        sum += v</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := adder()</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;0 + 1 + ... + %d = %d\n&quot;</span>, i, a(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包与Python类似，里面有函数体，函数体里有局部变量和自由变量（e.g.,<code>sum</code>）。</p><p>对应的Python闭包方式 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">adder</span>():</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">value</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> <span class="built_in">sum</span></span><br><span class="line">        <span class="built_in">sum</span> += value</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure>其中<code>nonlocal</code>就是标准，表示该变量不是局部变量</p><h2 id="缺点">缺点</h2><p>但是 Go中的函数式编程因为不像Python一样不用限制类型（泛型的缺失，ducktyping），就会导致后续代码会很难维护</p><p>比如 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> list = []<span class="type">string</span>&#123;<span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Grape&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// we are passing the array and a function as arguments to mapForEach method.</span></span><br><span class="line">    <span class="keyword">var</span> out = mapForEach(list, <span class="function"><span class="keyword">func</span><span class="params">(it <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(it)</span><br><span class="line">    &#125;)</span><br><span class="line">    fmt.Println(out) <span class="comment">// [6, 5, 6, 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The higher-order-function takes an array and a function as arguments</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapForEach</span><span class="params">(arr []<span class="type">string</span>, fn <span class="keyword">func</span>(it <span class="type">string</span>)</span></span> <span class="type">int</span>) []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> newArray = []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, it := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    <span class="comment">// We are executing the method passed</span></span><br><span class="line">    newArray = <span class="built_in">append</span>(newArray, fn(it))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果想包装一下，给别人用，那就得用泛型了，不然别人要是想用<code>map[int]</code>，那不就得开发一个<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapInt64ForEach</span><span class="params">(arr []<span class="type">int64</span>, fn <span class="keyword">func</span>(it <span class="type">int64</span>)</span></span> <span class="type">int</span>) []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> newArray = []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, it := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    <span class="comment">// We are executing the method passed</span></span><br><span class="line">    newArray = <span class="built_in">append</span>(newArray, fn(it))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="采用高阶函数的递归">采用高阶函数的递归</h2><p>借用 fibonacci 的实现我们简单地示例返回一个函数的方式来实现递归：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := fibonacci()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(f())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次输出：1 1 2 3 5 8 13 21 34 55</span></span><br></pre></td></tr></table></figure></p><h2 id="延迟计算-delayed-calculating">延迟计算 Delayed Calculating</h2><p>使用高阶/匿名函数的一个重要用途是捕俘变量和延迟计算，也即所谓的惰性计算（Lazyevaluations）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSth</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  err = io.EOF</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSth() <span class="comment">// printed: EOF</span></span><br></pre></td></tr></table></figure><p>在 <code>defer</code> 的高阶函数中，捕俘了外部作用域中的<code>err</code> 变量，doSth 的整个运行周期中对 <code>err</code>的设定，最终能够在 <code>defer</code>函数体中被正确计算得到。如果没有捕俘和延迟计算机制的话，高阶函数体中对<code>err</code> 的访问就只会得到 <code>nil</code> 值，因为这是捕俘时刻<code>err</code>的具体值。换句话说，在高阶函数中对外部作用域的访问是动态地延迟地计算的。</p>]]></content>
    
    
    <summary type="html">Golang Functional Programming in brief</summary>
    
    
    
    <category term="Programming Languages" scheme="https://jerry20000730.github.io/categories/Programming-Languages/"/>
    
    
    <category term="Go" scheme="https://jerry20000730.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>【C++】C++11 互斥量解决多线程数据共享问题</title>
    <link href="https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/multi-threading2/"/>
    <id>https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/multi-threading2/</id>
    <published>2024-09-02T15:18:56.000Z</published>
    <updated>2024-09-02T15:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据共享问题分析">数据共享问题分析</h2><p>在多个线程中共享数据时，需要注意线程安全问题。如果多个线程同时访问同一个变量，并且其中至少有一个线程对该变量进行了写操作，那么就会出现数据竞争问题。数据竞争可能会导致程序崩溃、产生未定义的结果，或者得到错误的结果。</p><p><em>为了避免数据竞争问题，需要使用同步机制来确保多个线程之间对共享数据的访问是安全的</em>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        shared_data++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;shared_data = &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，由于 shared_data变量是全局变量，因此在两个线程中共享。对于这种共享的情况，需要使用互斥量等同步机制来确保多个线程之间对共享数据的访问是安全的。如果不使用同步机制，就会出现数据竞争问题，导致得到错误的结果。</p><p>常见的同步机制包括 1. 互斥锁 2. 条件变量 3. 原子操作</p><h3 id="互斥锁">互斥锁</h3><p>互斥量（mutex）是一种用于实现多线程同步的机制，用于确保多个线程之间对共享资源的访问互斥。互斥量通常用于保护共享数据的访问，以避免多个线程同时访问同一个变量或者数据结构而导致的数据竞争问题。</p><p>互斥量提供了两个基本操作： - <code>lock()</code> -<code>unlock()</code></p><p>当一个线程调用 <code>lock()</code>函数时，如果互斥量当前没有被其他线程占用，则该线程获得该互斥量的所有权，可以对共享资源进行访问。如果互斥量当前已经被其他线程占用，则调用<code>lock()</code> 函数的线程会被阻塞，直到该互斥量被释放为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        mtx.<span class="built_in">lock</span>();</span><br><span class="line">        shared_data++;        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; n </span><br><span class="line">        &lt;&lt; <span class="string">&quot; increment shared_data to &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final shared_data = &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lock_guard-和-stdunique_lock"><code>lock_guard</code> 和<code>std::unique_lock</code></h3><p><code>std::lock_guard</code> 是 C++标准库中的一种互斥量封装类，用于保护共享数据，防止多个线程同时访问同一资源而导致的数据竞争问题。</p><p>std::lock_guard 的特点如下： -当构造函数被调用时，该互斥量会被自动锁定。 -当析构函数被调用时，该互斥量会被自动解锁。 -<code>std::lock_guard</code>对象不能复制或移动，因此它只能在局部作用域中使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 使用 lock_guard 自动管理锁</span></span><br><span class="line">        shared_data++;        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; n </span><br><span class="line">                  &lt;&lt; <span class="string">&quot; increment shared_data to &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// lock_guard 在作用域结束时自动解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();    </span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final shared_data = &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>std::unique_lock</code> 是 C++标准库中提供的一个互斥量封装类，用于在多线程程序中对互斥量进行加锁和解锁操作。它的主要特点是可以对互斥量进行更加灵活的管理，包括延迟加锁、条件变量、超时等。</p><p><code>std::unique_lock</code> 提供了以下几个成员函数： -<code>lock()</code>：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁。-<code>try_lock()</code>：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则函数立即返回false，否则返回 true。 -<code>try_lock_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</code>：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间。-<code>try_lock_until(const std::chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)</code>：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间点。- <code>unlock()</code>：对互斥量进行解锁操作。</p>]]></content>
    
    
    <summary type="html">在多个线程中共享数据时，需要注意线程安全问题。如果多个线程同时访问同一个变量，并且其中至少有一个线程对该变量进行了写操作，那么就会出现数据竞争问题</summary>
    
    
    
    <category term="Programming Languages" scheme="https://jerry20000730.github.io/categories/Programming-Languages/"/>
    
    
    <category term="C++ Multithreading" scheme="https://jerry20000730.github.io/tags/C-Multithreading/"/>
    
  </entry>
  
  <entry>
    <title>【C++】C++11 Thread线程库的基本使用</title>
    <link href="https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/multi-threading1/"/>
    <id>https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/multi-threading1/</id>
    <published>2024-09-02T15:10:31.000Z</published>
    <updated>2024-09-02T15:10:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建线程">创建线程</h1><p>C++11中，我们可以使用函数指针、函数对象或lambda表达式来实现。创建线程的基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(function_name, args...)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>function_name</code>是线程入口点的函数或可调用对象</p></li><li><p><code>args...</code> 是传递给函数的参数</p></li></ul><p>创建线程后，我们可以使用<code>t.join()</code>等待线程完成，或者使用<code>t.detach()</code>分离线程，让它在后台运行。</p><p>Example: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(print_message)</span></span>;    </span><br><span class="line">    t.<span class="built_in">join</span>();    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="传递参数">传递参数</h1><p>使用函数参数、全局变量、引用都可以向线程传递参数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    ++x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string message = <span class="string">&quot;Hello, world!&quot;</span>;    </span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(print_message, message)</span></span>;    </span><br><span class="line">    t.<span class="built_in">join</span>();    </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;    </span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment, std::ref(x))</span></span>;    </span><br><span class="line">    t2.<span class="built_in">join</span>();    </span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，当我们使用引用传递参数时，我们需要使用<code>std::ref</code> 来包装引用，否则编译器会报错。</p><p>在 C++ 中，<code>std::thread</code>构造函数模板接受可调用对象和参数时，会复制传递给它们的参数，防止因多个线程同时修改同一数据而可能引起的访问冲突或数据竞争。然而，在某些情况下，你实际上希望线程直接作用于原始变量或对象，而不是副本，这里的<code>increment</code> 函数设计为修改传递给它的原始整数</p><h1 id="等待线程完成">等待线程完成</h1><p>使用<code>t.join()</code>方法来等待线程完成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;    </span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(print_message, <span class="string">&quot;Thread 1&quot;</span>)</span></span>;    </span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(print_message, <span class="string">&quot;Thread 2&quot;</span>)</span></span>;    </span><br><span class="line">    t1.<span class="built_in">join</span>();    </span><br><span class="line">    t2.<span class="built_in">join</span>();    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;All threads joined&quot;</span> &lt;&lt; std::endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分离线程">分离线程</h1><p>与 <code>join</code>不同，我们可能不需要等待线程完成，而是希望它在后台运行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;    </span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(print_message, <span class="string">&quot;Thread 1&quot;</span>)</span></span>;    </span><br><span class="line">    t.<span class="built_in">detach</span>();    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread detached&quot;</span> &lt;&lt; std::endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="joinable"><code>joinable()</code></h1><p>joinable()方法返回一个布尔值，如果线程可以被join()或detach()，则返回true，否则返回false。如果我们试图对一个不可加入的线程调用join()或detach()，则会抛出一个std::system_error异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread started&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(foo)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread joined&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程函数中的数据未定义错误">线程函数中的数据未定义错误</h1><h2 id="传递临时变量">传递临时变量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(foo, <span class="number">1</span>)</span></span>; <span class="comment">// 传递临时变量</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建了一个名为<code>t</code>的线程，将<code>foo</code>函数以及一个临时变量<code>1</code>作为参数传递给（int引用）。这样会导致在线程函数执行时，临时变量<code>1</code>被销毁，从而导致未定义行为。</p><h2id="传递指向局部变量的指针或引用">传递指向局部变量的指针或引用：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl; <span class="comment">// 访问已经被销毁的指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(foo, &amp;x)</span></span>; <span class="comment">// 传递指向局部变量的指针</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="section"></h2><h1 id="reference">Reference</h1><ol type="1"><li><a href="http://www.seestudy.cn/?list_9/31.html">C++11Thread线程库的基本使用</a></li></ol>]]></content>
    
    
    <summary type="html">C++11 Thead线程库的基本使用，包括如何创建线程、启动线程、等待线程完成以及如何分离线程。</summary>
    
    
    
    <category term="Programming Languages" scheme="https://jerry20000730.github.io/categories/Programming-Languages/"/>
    
    
    <category term="C++ Multithreading" scheme="https://jerry20000730.github.io/tags/C-Multithreading/"/>
    
  </entry>
  
  <entry>
    <title>【C++】如何在C++中实现单例模式</title>
    <link href="https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/singleton/"/>
    <id>https://jerry20000730.github.io/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/singleton/</id>
    <published>2024-09-02T15:02:49.000Z</published>
    <updated>2024-09-02T15:02:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="懒汉式单例模式lazy-singleton">1. 懒汉式单例模式（LazySingleton）</h2><p>懒汉式单例牧师只有在第一次使用的时候才创建实例</p><h3 id="实现代码">1.1 实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取唯一实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        std::<span class="built_in">call_once</span>(initFlag, []() &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除复制构造函数和赋值操作符，防止复制实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个测试方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from Singleton!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 静态成员变量保存唯一实例</span></span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="comment">// std::call_once需要的标志，用于初始化一次性操作</span></span><br><span class="line">    <span class="type">static</span> std::once_flag initFlag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员变量初始化</span></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::once_flag Singleton::initFlag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* singleton = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    singleton-&gt;<span class="built_in">showMessage</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>getInstance</code>方法：使用<code>std::call_once</code>来确保<code>instance</code>只被初始化一次，即使在多线程环境下也是安全的。</p><h2 id="饿汉式单例模式">2. 饿汉式单例模式</h2><p>饿汉式单例模式在类加载的时候就创建好一个静态实例，不管之后是否会用到这个实例。在多线程下是线程安全的。</p><h3 id="实现代码-1">2.1 实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取唯一实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除复制构造函数和赋值操作符，防止复制实例</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个测试方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from Singleton!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员变量保存唯一实例</span></span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员变量初始化</span></span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* singleton = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    singleton-&gt;<span class="built_in">showMessage</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><ol type="1"><li>【字节跳动】如何在C++中实现单例模式？<span class="citation"data-cites="Lynn77-QAQ">@Lynn77-QAQ</span> <ahref="https://www.bilibili.com/video/BV1NWs4ezEn5/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=243ce9423fb82c395b4e9e6bf321ae0c">https://www.bilibili.com/video/BV1NWs4ezEn5/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=243ce9423fb82c395b4e9e6bf321ae0c</a></li></ol>]]></content>
    
    
    <summary type="html">C++实现单例模式为常考题。</summary>
    
    
    
    <category term="Programming Languages" scheme="https://jerry20000730.github.io/categories/Programming-Languages/"/>
    
    
    <category term="C++ singleton" scheme="https://jerry20000730.github.io/tags/C-singleton/"/>
    
  </entry>
  
</feed>
