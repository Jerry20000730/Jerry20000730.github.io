{"posts":[{"title":"git commit -m &quot;Welcome Friend&quot;","text":"Welcome to the index page of Tragic Master's Wiki Site. Most of the wiki are pre-recorded in a different software (Yuque or Notion). Some of them are incomplete, while complete ones are uploaded to this website for knowledge sharing. The initial aspiration of establishing this website is actually very amusing. This website has been re-established after the last server went down all of a sudden (I don't know why). However, because of the fact that the configuration of the last website is not recorded, all of the information was gone and I have to restart a new website all from scratch. It is at that moment that I realize how important it is to record the process of software configuration/development/maintanance. The wiki will intend to reduce second effort, improve efficiency and make the knowledge accessible to me anytime. If interested in collaboration, please send email to tragicmaster@outlook.com. Thank you.","link":"/wiki/index/"},{"title":"ECE 560 Computer and Information Security Homework 5","text":"","link":"/wiki/duke-ece560-pdf-hw5/"},{"title":"ECE 560 Computer and Information Security Homework 4","text":"","link":"/wiki/duke-ece560-pdf-hw4/"},{"title":"ECE 560 Computer and Information Security Homework 3","text":"","link":"/wiki/duke-ece560-pdf-hw3/"},{"title":"ECE 560 Computer and Information Security Homework 2","text":"","link":"/wiki/duke-ece560-pdf-hw2/"},{"title":"ECE 560 Computer and Information Security Homework 1","text":"","link":"/wiki/duke-ece560-pdf-hw1/"},{"title":"MIT 6.5840 Distributed System Lab1 MapReduce","text":"Intro 实验是实现一个简单版本的MapReduce系统","link":"/wiki/mit5840/lab1/"},{"title":"Docker Hub 镜像命名规则","text":"Docker Hub上的镜像命名规则是什么 镜像会分版本，虽然直接使用latest固然方便，但是在生产环境不可以这么做，会导致版本不可控（版本太重要了）。 通常来说，镜像标签的格式是应用的版本号+操作系统，其中版本号为主版本号+次版本号+补丁号，有的还会再正式发布前出rc版本（release candidate）。 有的标签还会加上slim，fat来进一步表示这个镜像的内容是经过精简的，还是包含了比较多的辅助工具，通常slim镜像会比较小，运行效率高，而fat镜像会比较大，适合用来进行开发调试。 胖容器 和 瘦容器 胖容器 = “一锅端”打进去的操作系统 + 运行时 + 应用，可立即跑，体积大、攻击面广、更新重。 瘦容器 = 仅保留跑起来必需的内容，多阶段 / distroless 制作，体积小、安全、传输快，但打包和排错更精细。 如何上传自己的镜像 Docker Hub上注册一个用户 在本机上使用docker login功能，用注册的用户名和密码认证身份登录 【重要】docker tag命令，给镜像改成带用户名的完整名字，表示镜像是属于这个用户的，或者你直接在docker build -t在创建镜像的时候就起好名字 12docker tag ngx-app tragicmaster/ngx-app:1.0docker images docker push 离线环境该怎么办 使用Docker Hub来管理镜像是非常方便，但是企业内网的离线环境，自然也就不能用docker push，docker pull来推送 最佳的方法是在内网环境里伪造Docker Hub，创建一个自己私有的Registry服务，就像自己搭一个Github一样，目前自建Registry有很多成熟的解决方案，比如Docker Registry，CNCF Harbor，腾讯内部使用的是Docker Registry。","link":"/wiki/Cloud-Native/docker2/"},{"title":"Docker 镜像和 DockerFile","text":"镜像的内部机制 镜像本质是一个打包文件，里面包含了应用程序还有它运行所依赖的环境，例如文件系统，环境变量，配置参数等。环境变量和配置参数相对比较简单，真正麻烦的是文件系统。为了保证容器运行环境的一致性，镜像必须把应用程序锁在操作系统的根目录都包含进来，虽然这些文件里不包含kernel（容器共享宿主机kernel），但是如果每个镜像都重复做这样的打包操作，会有大量的冗余。 很自然的，我们就会想到将重复的部分抽取出来，存放一份根目录文件（比如Ubuntu），然后让所有镜像以某种方式共享这部分数据，这种方式就是分层（Layer） 容器的内部是由多个镜像层组成的，每层都是只读不可修改的一组文件，相同的层可以在镜像之间共享，然后多个层像搭积木一样堆叠起来，再使用一种叫做“联合文件系统（Union FS）“的方式将他们合并在一起，就形成了容器最终看到的文件系统。 联合文件系统（Union File System， UnionFs）可以将不同物理位置的目录合并、挂载到同一个目录中，即便目录的物理位置是分开的。UnionFs 把文件系统的每一次修改作为一个个层进行叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。如果一次同时加载多个文件系统，UnionFs 会把各层文件叠加起来，最终文件系统会包含所有底层文件和目录，从外部视角看，就是一个完成的文件系统。 容器镜像设计中，为了解决各类依赖以及依赖共享，正是利用 UnionFs 实现了镜像分层，再结合 bootfs、rootfs，一层层继承、叠加。启动容器时把相关的层挂载到一个目录，作为容器的根文件系统，这就是容器镜像的原理。 使用命令docker inspect可以查看镜像的分层信息，比如 1docker inspect nginx:alpine 可以看到他的分层信息在\"RootFS\"的部分 1234567891011121314&quot;RootFS&quot;: { &quot;Type&quot;: &quot;layers&quot;, &quot;Layers&quot;: [ &quot;sha256:a16e98724c05975ee8c40d8fe389c3481373d34ab20a1cf52ea2accc43f71f4c&quot;, &quot;sha256:2daa38453f3839c68c18e7af10f04bf2259d432c05dce454841e24a129b53009&quot;, &quot;sha256:d4261a1a67711866f8c31560e2326a631464f86c0a711c843cf6026dece885e8&quot;, &quot;sha256:7d5d0920762752b29bf4329267456cad14f3ee902ef40179eb466c7a4eeaf4e7&quot;, &quot;sha256:b4896f69ba7afecb40f6badf4287761288eab9952c7132ab900098fb2f28c16d&quot;, &quot;sha256:61b204e6ce207d2ef4ed25e628fb08eaa1326173b78a218164d70d353cac9438&quot;, &quot;sha256:1b69eff9b9cc79db4b61e434fe73334618dc3b7077fb9eb095db31b278a768ef&quot;, &quot;sha256:60841a212b982e785aa9aa5aa7e7eea1128e7143829dd0b9ab3cd481f27d5e3d&quot;, &quot;sha256:43628cfc79f5984e0a5287e2855b2131b3597c3dac57cc4525fefc2cf0052d7d&quot; ]}, 通过这个信息可以看出，nginx:alpine镜像由8个layer，所以你在使用docker pull的时候那些奇怪的输出信息是啥了 Dockerfile是什么 知道了容器内部的结构和基本原理，就可以学习如何自己动手制作镜像了，也就是自己打包应用。如果我么将容器看成”现房“，镜像就是”样板间“，那么造出这个样板间我们需要”施工图纸“，施工图纸就是Dockerfile 假设我们有一个Dockerfile: 12FROM busyboxCMD echo &quot;hello world&quot; 那么这个文件里只有两个指令，第一条指令是FROM，所有的Dockerfile都要从他开始，表示构建使用的基础镜像。第二条指令是CMD，它指定docker run启动容器时默认执行的命令。有了”施工图纸“，就可以使用docker build命令创建出镜像： 12345678910docker build -f Dockerfile.busybox .Sending build context to Docker daemon 7.68kBStep 1/2 : FROM busybox ---&gt; d38589532d97Step 2/2 : CMD echo &quot;hello world&quot; ---&gt; Running in c5a762edd1c8Removing intermediate container c5a762edd1c8 ---&gt; b61882f42db7Successfully built b61882f42db7 其中-f参数指定Dockerfile文件名，后面必须跟一个文件路径，称为构建上下文（build context） 从命令输出也能看出，docker build 不是在本地运行的，而是将所有的目录和运行环境打包传给远端，通过Docker daemon进行拉取镜像，打包，包装到容器中，参考下面这张图： docker principle 注意：使用上下文查找文件只能查找一级，不能递归向下查找第二级，比如： example file structure 如果指定路径为.，也就是当前路径，那么如果我想执行命令 1COPY hello.txt . 就会报错，因为hello.txt在docker文件夹下面，不在helloworld-app的文件下，但是上下文只会查询一级，不会向下查询第二级。","link":"/wiki/Cloud-Native/docker1/"},{"title":"Go Programming Languages - 框架篇 - 日志 - Zap","text":"Zap zap是uber开发的一个日志框架，相较于logrus来说，性能要好一些，公司内部也会用zap来进行日志的格式规范。 类型 zap内置三种logger，对于NewProduction生产环境中运用的logger，会设置日志级别为info（意味着debugger不会被输出），error及error以上会打印调用堆栈，会上报位置。 123logger := zap.NewExample() // 测试logger := zap.NewDevelopment() // 开发环境logger, _ := zap.NewProduction() zap的性能之所以比较好，很大一部分原因是因为日志里面需要显式地声明数据的类型，比如zap.Int，zap.Namespace。 123logger.Debug(&quot;hello&quot;)logger.Info(&quot;hello&quot;, zap.Int(&quot;age&quot;, 18))logger.Error(&quot;hello&quot;, zap.Namespace(&quot;china&quot;), zap.Int(&quot;age&quot;, 18)) 一般来说，不需要定制log的，直接使用logger := zap.NewDevelopment() 或 logger, _ := zap.NewProduction()即可，但如果需要定制部分功能的，需要灵活操作的，则可以使用logger.New()进行定制 123456789101112131415161718192021222324252627file, err := os.OpenFile(logFile, os.O_CREATE|os.O_APPEND|os.O_WRONLY, os.ModePerm)if err != nil { panic(err)}encoderConfig := zap.NewProductionEncoderConfig()encoderConfig.EncodeTime = zapcore.TimeEncoderOfLayout(&quot;2006-01-02 15:04:05.000&quot;) // 指定时间格式，不是时间戳// {&quot;level&quot;:&quot;info&quot;,&quot;ts&quot;:1744551191.6673155,&quot;caller&quot;:&quot;io/zap_test.go:13&quot;,&quot;msg&quot;:&quot;hello&quot;,&quot;age&quot;:18}// ts 换成 timeencoderConfig.TimeKey = &quot;time&quot;// level的显示样式为大写encoderConfig.EncodeLevel = zapcore.CapitalLevelEncodercore := zapcore.NewCore( // zapcore.NewJSONEncoder(encoderConfig) zapcore.NewConsoleEncoder(encoderConfig), zapcore.AddSync(file), zapcore.InfoLevel,)logger := zap.New( core, zap.AddCaller(),)return logger 也可以使用第三方日志轮询库，如之前提到的rotatelogs或者lumberjack(https://github.com/natefinch/lumberjack.git) zap与logrus一样，可以添加钩子 1234567891011logger := zap.New( core, zap.AddCaller(), zap.AddStacktrace(zapcore.ErrorLevel), zap.Hooks(func(e zapcore.Entry) error { if e.Level &gt;= zapcore.ErrorLevel { fmt.Println(e.Message) } return nil })) 上述代码在error级别及以上的日志可以在终端中打印错误的message，比如logger.Error(\"hello\", zap.Namespace(\"china\"), zap.Int(\"age\", 18))则会打印hello。zap.AddStacktrace(zapcore.ErrorLevel)允许在error level及其以上打印调用堆栈 123452025-04-13 23:03:20.000 ERROR io/zap_test.go:22 hello {&quot;china&quot;: {&quot;age&quot;: 18}}github.com/Jerry20000730/go-framework/io.TestZap2 /home/guofangcheng/go-framework/io/zap_test.go:22testing.tRunner /usr/local/go/src/testing/testing.go:1792 如果需要公共的field，可以使用logger.With 1234logger = logger.With( zap.Namespace(&quot;system&quot;) zap.String(&quot;T-uuid&quot;, uuid.New().String())) 打印出来的公共参数： 1234562025-04-13 23:09:44.954 INFO io/zap_test.go:21 hello {&quot;system&quot;: {&quot;T-uuid&quot;: &quot;091dfb4e-c6a3-463e-9dd0-67c02521c7ee&quot;, &quot;age&quot;: 18}}2025-04-13 23:09:44.954 ERROR io/zap_test.go:22 hello {&quot;system&quot;: {&quot;T-uuid&quot;: &quot;091dfb4e-c6a3-463e-9dd0-67c02521c7ee&quot;, &quot;china&quot;: {&quot;age&quot;: 18}}}github.com/Jerry20000730/go-framework/io.TestZap2 /home/guofangcheng/go-framework/io/zap_test.go:22testing.tRunner /usr/local/go/src/testing/testing.go:1792","link":"/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_framework_log2/"},{"title":"Go Programming Languages - 框架篇 - 日志 - Logrus","text":"日志作用 定位问题 - 这个就不用多说了，平常排查问题用的最多的方法就是看日志 监控 - 这个没咋用过，留个空 业务分析 - 统计数据吧，比如有多少请求，多少次I/O请求啥的 日志级别(程度由低到高，大体上是这个顺序) DEBUG INFO WARN ERROR FATAL Logrus介绍 https://github.com/sirupsen/logrus 根据github介绍，logrus的定义是 Logrus is a structured logger for Go (golang), completely API compatible with the standard library logger. logrus完全兼容标准的log库，还支持文本、JSON 两种日志输出格式 1go get github.com/sirupsen/logrus 指定输出格式 文本输出格式 1234logger.SetFormatter(&amp;logrus.TextFormatter{ DisableColors: true, // 强制不显示颜色 TimestampFormat: &quot;2006-01-02 15:04:05.000&quot;, // 显示ms}) JSON输出格式 123logger.SetFormatter(&amp;logrus.JSONFormatter{ TimestampFormat: &quot;2006-01-02 15:04:05.000&quot;,}) 这个包的问题：不会进行日志轮询，即定期进行清理，避免log文件不断大下去 有一个包叫rotatelogs，但已经不维护了 rotatelogs介绍 https://github.com/lestrrat-go/file-rotatelogs 根据定义，rotatelogs的作用是 Provide an io.Writer that periodically rotates log files from within the application 也就是说在应用程序内定期轮换日志文件 安装命令 1go get github.com/lestrrat-go/file-rotatelogs rotatelogs可以指定： 日志名格式 软链接 每隔多少时间生成一份日志 最大保存期限 123456fout, err := rotatelogs.New( logFilePath+&quot;.%Y%m%d%H&quot;, // 指定日志文件的路径和名称，路径不存在的时候会创建 rotatelogs.WithLinkName(logFilePath), // 为最新的一份日志创建软链接 rotatelogs.WithRotationTime(1*time.Hour), // 每隔1小时生成一份新的日志文件 rotatelogs.WithMaxAge(7*24*time.Hour), // 只留最近7天的日志，或使用WithRotationCount，表示只保留最近的几份日志) 设置日志输出方式 123456// 设置为日志文件输出logger.SetOutput(fout)// 设置为终端输出logger.SetOutput(os.Stdout)// 设置为不输出log.SetOutput(ioutil.Discard) 设置日志调用关系 1logger.SetReportCaller(true) 这样输出的日志就会带上method，比如： 12{&quot;animal&quot;:&quot;penguin&quot;,&quot;level&quot;:&quot;fatal&quot;,&quot;method&quot;:&quot;github.com/sirupsen/arcticcreatures.migrate&quot;,&quot;msg&quot;:&quot;a penguin swims by&quot;,&quot;time&quot;:&quot;2014-03-10 19:57:38.562543129 -0400 EDT&quot;} 钩子（Hooks） 简单来说就是打印日志的时候顺带会执行的操作，比如发短信啦，接入一些平台bot发消息啦 logrus支持hooks请参考官网：https://github.com/sirupsen/logrus/wiki/Hooks 自定义钩子 实现hook的两个方法，一个是Levels，表示适用于哪些等级，另一个是Fire，表示具体做法 1234567891011121314151617// 实现logurs.Hook接口type AppHook struct { AppName string}// 适用于哪些Levelfunc (h *AppHook) Levels() []logrus.Level { return []logrus.Level{logrus.ErrorLevel, logrus.FatalLevel, logrus.PanicLevel}}// 在Fire函数时可读取或修改logrus.Entryfunc (h *AppHook) Fire(entry *logrus.Entry) error { entry.Data[&quot;app&quot;] = h.AppName // 这里你可以将Error Fatal 和 Panic级别的错误日志发送到kafka fmt.Println(entry.Message) return nil} 其中Entry的结构是 123456789101112131415161718192021222324252627282930type Entry struct { Logger *Logger // Contains all the fields set by the user. Data Fields // Time at which the log entry was created Time time.Time // Level the log entry was logged at: Trace, Debug, Info, Warn, Error, Fatal or Panic // This field will be set on entry firing and the value will be equal to the one in Logger struct field. Level Level // Calling method, with package name Caller *runtime.Frame // Message passed to Trace, Debug, Info, Warn, Error, Fatal or Panic Message string // When formatter is called in entry.log(), a Buffer may be set to entry Buffer *bytes.Buffer // Contains the context set by the user. Useful for hook processing etc. Context context.Context // err may contain a field formatting error err string}type Fields map[string]interface{} 对应生成的日志就是中的话，Message就是msg，Level就是level，实际存储在的是Data变量中 1{&quot;age&quot;:18,&quot;file&quot;:&quot;/home/guofangcheng/go-framework/io/logrus_test.go:14&quot;,&quot;func&quot;:&quot;github.com/Jerry20000730/go-framework/io.TestLogrus&quot;,&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;this is info log&quot;,&quot;name&quot;:&quot;test&quot;,&quot;time&quot;:&quot;2025-03-24 01:03:48.080&quot;} 示例代码就是做了个简单的处理，实际可以做更为复杂的逻辑，比如加入kafka，对接到提醒bot等。并且因为修改了Data，所以本质上可以修改他的日志输出内容。","link":"/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_framework_log/"},{"title":"Go Programming Languages - Go Module Version","text":"Go Module 版本规范 Go module 每个版本以v开头，后面跟_语义版本_。当vcs为git时候，通常情况下模块的版本会是git tag的版本 当没有语义版本的时候，会生成一个伪版本，例如v0.0.0-20190306012644-bacd9c7ef1dd这种，其中第二部分代表代码生成的时间，第三部分是这个代码当前commit的id的前12个字符。（可以通过git log来查看） 主版本为2或更高版本的时候，go模块路径必须带有类似于/v2或/v3这样的主版本后缀，比如github.com/gocolly/colly/v2，github.com/mailru/go-clickhouse/v2，这就是为什么go get或go install的时候可以指定版本号，如： 1go get github.com/cespare/xxhash@v1.1.0 主版本号不同表示不兼容，一个项目里可能同时依赖不同的主版本号，比如 1234import ( &quot;gopkg.in/yaml.v2&quot; yaml3 &quot;gopkg.in/yaml.v3&quot;) go get -u不会更新主版本号，即-u表示更新到当前主版本号下的最新版本 在使用go module规范之前，有些第三方库的高版本没有加/v2或/v3后缀，此时需要加incompatible，如github/go-redis/redis v6.15.9+incompatible路径没有/v6后缀 主版本后缀不允许有/v0或/v1出现 一种特殊情况：以gopkg.in/开头的模块路径必须始终具有主版本后缀。后缀必须以点开头，而不是斜杠，例如gopkg.in/check.v1，gopkg.in/yaml.v3","link":"/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_module/"},{"title":"Go Programming Languages - Extra Settings","text":"Go module Go module的原理 go module 根据官网定义 A Go module is a collection of Go packages stored in a file tree with a go.mod file at its root 在Go Module没有出现之前，所有依赖距均从$GOPATH/src/ 或 $GOROOT/src/ 中进行查找导入，Go Modules 是为了提升使用其他开发者代码，即添加依赖项（模块、包）时的体验，也是为了让代码的正确性、安全性得到保障。 在 Go 支持 Go Modules 之后，编译时编译器会从工作目录（当前所在目录）开始并逐级向上查找是否具有 go.mod 文件。 如何开启？ 用环境变量 GO111MODULE 开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是 auto。 GO111MODULE=off 无模块支持，Go 会从 GOPATH 和 vendor 文件夹寻找包。 GO111MODULE=on 模块支持，Go 会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。 GO111MODULE=auto 在 $GOPATH/src 外面且根目录有 go.mod 文件时，开启模块支持。 注意：在使用模块的时候，GOPATH 是无意义的，不过它还是会把下载的依赖储存在 $GOPATH/src/mod 中，也会把 go install 的结果放在 $GOPATH/bin 中 如何初始化一个module 1go mod init ${module_name} Go module 名称 module名称有模块路径标识，模块路径就是模块的规范名称，为了规范，很多公司会将确保模块名称加上https://的前缀就是源码仓库的地址。 举例： 这样做的目的是为了方便其他公司/组织的人下载依赖时使用 注意： 1. 模块名可以不是源码仓库地址 2. 模块名称可以包含子目录 下面讨论如何下载，已经如果模块名称不为实际下载地址的时候Go module是如何解决的。 如何下载Go Module（下载自己项目的依赖项）？ 一般来说，只需要知道你需要下载的module名称即可，比如我需要下载上图testify的包，我只需要： 1go get github.com/stretchr/testify 但有的时候，一些module的名称与源码仓库地址不一样，比如下图： 当执行get命令的时候： 1go get go.uber.org/zap 会先向https://go.uber.org/zap?go-get=1发送一个GET请求 此时，响应体里会有一个meta标签，name为go-import，对应的content由三部分组成： 1234# 1. 模块名称# 2. 版本控制工具（git还是svn）# 3. 实际的源码仓库地址go.uber.org/zap git https://github.com/uber-go/zap 如何下载模块中的子模块（下载自己项目的依赖项中的其中一个模块）？ 假设我需要的不是zap这个项目的所有源码，而是其中一个模块，比如 1go get go.uber.org/zap/tools 他的查找顺序如下： 1. 先发送GET请求https://go.uber.org/zap/tools?go-get=1，发现查不到源码地址 2. 再回溯一级目录，请求https://go.uber/org/zap?go-get=1 公司里面的做法 公司里面一般我们会直接go get xxxx/repo.git，这个时候就会直接克隆这个git地址的目录，无需再发送go-get=1的请求 一般来说，公司里面实际上会使用ssh的方式解决权限问题，比如使用git的时候我们会在$HOME/.gitconfig文件中追加 12[url &quot;ssh://git@xxx.com&quot;] insteadOf = https://xxx.com 通过在git平台上传ssh公钥的方式解决权限问题 GOPROXY GOPROXY原理 几个问题： 1. 互联网上的源码仓库除了github还有很多，在各种不同的网络环境下，如何保证下载速度？ 2. 默认情况下，go get不是直接去源码仓库上下载代码，而是通过代理https://proxy.golang.org(谷歌维护)去下载，代理对源码镜像进行了缓存并提供了CDN加速，但是源码更新几分钟后，代理里的镜像才会更新会有一定延迟。 国内代理有： 12https://goproxy.cnhttps://goproxy.io 我们可以在GOPROXY环境变量下进行更改，以确保当谷歌的下载不下来的时候，可以使用国内代理下载。 模块缓存 下载的谋爱会保存在环境变量GOMODCACHE指定的目录下，默认为$GOPATH/pkg/mod GOSUMDB sum.golang.org (由谷歌运行)提供了一个checksum数据库，用来存储源代码的哈希值，以防止go get从任何源头（包括代理）拉取了被篡改的源码。 第一次用go get下载某个模块的时候，会计算其哈希值，与checksum数据库里的值进行对比， 如果一致，则把模块存入本地缓存目录，并将哈希值写入go.sum文件。后续使用该模块时通过go.sum文件来校验该模块自下载以来未曾被修改过。 如果设置环境变量GOSUMDB=off，或者go get的时候使用-insecure标志，标识不需要验证合法性。 如何使用公司内部私有的Go module GOPROXY的默认值（https://proxy.golang.org,direct），其中direct表示不走代理，直接从源码库下载（先发送go-get=1请求） 所有代理都不会访问私有仓库，所以go get私有模块的时候会命中direct，所有代理都不会访问私有仓库，所以go get私有模块的时候会命中direct。为避免下载私有模块的时候访问代理，可以把私有模块的前缀赋给GONOPROXY，如GONOPROXY=xxx.xxx.com 私有模块不需要使用公共的checksum数据库，所以需要设置GONOSUMDB=xxx.xxx.com GOPRIVATE是GONOPROXY和GONOSUMDB的默认值，所以设置GOPRIVATE之后就不需要再设置GONOPROXY和GONOSUMDB 如何部署公司私有的GOPROXY goproxy.io除了提供国内可用的go module代理之外，还提供了部署私有go proxy的能力： https://github.com/goproxyio/goproxy.git 方法如下： 编译安装go proxy 123git clone https://github.com/goproxyio/goproxy.gitcd goproxymake 启动代码 1./bin/goproxy -listen=0.0.0.0:80 -cacheDir=$HOME/go_module_cache -proxy https://goproxy.io -exclude &quot;gitlab.xxx.com&quot; 其中 -cacheDir 是代理使用的缓存目录，跟GOMODCACHE区分开，如果私有代理商找不到模块，就去访问公开代理（也就是https://goproxy.io）。 -proxy指定公开代理 -exclude指定那些模块直接去代码仓库下载 最后将自己的GOPROXY设置为GOPROXY=xxx.com,direct，xxx.com就是你服务器的域名，80端口开放","link":"/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_extra/"},{"title":"CICD流水线搭建流程 [GitLab + Ubuntu]","text":"Prerequisite GitLab 仓库 Ubuntu (18.04/20.04/22.04) 服务器 编程语言runtime 1. 创建GitLab仓库 create gitlab repo 2. 创建GitLab Runner 服务器上先安装gitlab-runner服务 1sudo apt-get install gitlab-runner 检查安装是否成功 1systemctl status gitlab-runner 会显示 1234567● gitlab-runner.service - GitLab Runner Loaded: loaded (/etc/systemd/system/gitlab-runner.service; enabled; vendor preset: enabled) Active: active (running) since Mon 2020-06-01 09:01:49 UTC; 4s ago Main PID: 16653 (gitlab-runner) Tasks: 6 (limit: 1152) CGroup: /system.slice/gitlab-runner.service └─16653 /usr/lib/gitlab-runner/gitlab-runner run --working-directory /home/gitlab-runner --config /etc/gitlab 其次在GitLab上进行绑定，进入仓库 - Settings - CICD - Runners gitlab runner location 点击 New Project Runner, 然后写一下tag和description（确保你知道这个是那个服务器和干什么的），然后选中 Run untagged project，确保你不会因为该项目没有tag而无法在runner上跑 gitlab runner configure 3. 绑定gitlab-runner和服务器 当 gitlab-runner 注册之后，需要在服务器上进行token绑定 gitlab runner binding 输入基础命令 1gitlab-runner register --url [project_URL] --token [runner_token] 然后可能会让你输入几个关键信息 executor: 参照gitlab官方给出的executor类型，我们因为是个小项目，暂时没有使用docker，所以选择shell docker-image: 如果选择docker作为executor的话，就会要求配置docker镜像 description: 描述一下 等信息，其它我没遇到，遇到了再记录 4. 编写 .gitlab-ci.yml 首先是要填写流水线的阶段 1234stages: - build - test - deploy 其次是各阶段所需要的命令和生成的文件单独列举出来，因为我们这个是个springboot项目，每次推送main分支之后就会进行maven编译，生成target文件夹下的jar包，然后在java runtime运行，流水线思路简单。 12345678910111213141516171819202122232425build: stage: build script: - mvn clean package artifacts: paths: - target/*.jar expire_in: 1 weektest: stage: test script: - mvn testdeploy: stage: deploy script: - mkdir -p $DEPLOY_PATH - cp target/$APP_NAME $DEPLOY_PATH/ - | while pgrep -f &quot;$APP_NAME&quot; &gt; /dev/null; do pkill -f &quot;$APP_NAME&quot; sleep 1 done - nohup java -jar $DEPLOY_PATH/$APP_NAME --spring.profiles.active=prod &gt; $DEPLOY_PATH/app.log 2&gt;&amp;1 &amp; 其中 123456- | while pgrep -f &quot;$APP_NAME&quot; &gt; /dev/null; do pkill -f &quot;$APP_NAME&quot; sleep 1 done- nohup java -jar $DEPLOY_PATH/$APP_NAME --spring.profiles.active=prod &gt; $DEPLOY_PATH/app.log 2&gt;&amp;1 &amp; 是为了保证能够确保关掉上一次跑的进程。 Reference How To Set Up a Continuous Deployment Pipeline with GitLab CI/CD on Ubuntu https://www.digitalocean.com/community/tutorials/how-to-set-up-a-continuous-deployment-pipeline-with-gitlab-on-ubuntu Use CI/CD to build your application https://docs.gitlab.com/ee/topics/build_your_application.html","link":"/wiki/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/CICD/"},{"title":"部署SSL证书","text":"Prerequisite 申请免费证书 (腾讯云) 安装SSL证书（Nginx） 下载SSL文件 登录远程服务器 Reference Prerequisite 一个域名 Nginx服务器 申请免费证书 (腾讯云) 登录 SSL 证书控制台，进入我的证书页面，并单击申请免费证书。 填写证书申请表单，如下图所示： 其中： 证书绑定域名：网站域名 域名验证方式：一般选手动就可以，然后到域名解析商配置一下，因为本人是腾讯云买的，就比较方便，只需要到https://console.cloud.tencent.com/cns/domains 详情参考：https://cloud.tencent.com/document/product/400/54500 申请邮箱：请输入您的邮箱地址。 算法选择：RSA就行 安装SSL证书（Nginx） 以下针对于使用Nginx进行反向代理部署的服务器 下载SSL文件 等待审核通过之后，点击下载按钮并获取SSL证书 依据不同云服务器商要求下载对应版本（我下的是Nginx版本） 文件夹中会含有以下几个文件： 证书文件：xxx.crt 证书文件 密钥文件：xxx.key 私钥文件 CSR文件：xxx.csr 文件 PEM文件: xxx.pem 文件 我们只需要.crt和.key文件即可 登录远程服务器 WinSCP/PuTTY/我喜欢用Termius 将已获取到的 cloud.tencent.com_bundle.crt 证书文件和 cloud.tencent.com.key 私钥文件从本地目录拷贝到轻量应用服务器 Nginx 默认配置文件目录中 输入grep命令获取nginx配置目录（知道的略过这步） 1find / | grep nginx.conf 然后去配置文件nginx.conf或者site-enabled/default(我是后者)配置文件增加下列行数 12345678910server { listen 443 ssl default_server; listen [::]:443 ssl default_server; ssl_certificate cert/tragicmaster.website_bundle.crt; ssl_certificate_key cert/tragicmaster.website.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on;} 保存并使用以下命令检测nginx配置是否正确 1nginx -t 如果返回 12nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful 然后重新加载nginx (非常重要！不然换证书的时候容易检测不到) 1nginx -s reload 登录域名https://tragicmaster.website左上角成功变锁！ Reference Nginx服务器证书安装 https://cloud.tencent.com/document/product/1207/47027 linux下查看nginx的安装路径 https://blog.csdn.net/sinat_22387459/article/details/115007510 Nginx 安装 SSL 配置 HTTPS超详细完整全过程 https://developer.aliyun.com/article/761236","link":"/wiki/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/SSLBuild/"},{"title":"最长回文子串问题的解法","text":"问题分析 判断方法 中心拓展方法 二维动态规划方法 问题分析 力扣链接：https://leetcode.cn/problems/longest-palindromic-substring/description 给你一个字符串s，找到s种最长的回文子串 例如 s = \"babbad\" 的最长回文子串是 abba，长度为4 判断方法 从两边向中间，或者中间向两边拓展，不断比较头尾字符是否相同即可 中心拓展方法 思路：遍历每一个字符，向两百年拓展找到一起为中心的最长回文子串，所有找到的回文子串的最大长度即所求 12345678910111213141516171819202122class Solution: def longestPalindrome(self, s: str) -&gt; str: longest = &quot;&quot; for i in range(len(s)): # odd p = self.getPalindrome(s, i, i) if len(p) &gt; len(longest): longest = p # even p = self.getPalindrome(s, i, i+1) if len(p) &gt; len(longest): longest = p return longest def getPalindrome(self, s: str, left: int, right: int) -&gt; str: while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left+1:right] 二维动态规划方法 回文串两边加上两个相同字符，会变成一个新的回文串，建立二维数组dp，找出所有的回文子串，dp[i][j]记录子串i到j是否为回文串 初始化dp数组，所有一个字母都是回文串，所以dp[i][i] = True 得出递推关系： 如果s[i]和s[j]相等，并且子串dp[i+1][j-1] = True，那么dp[i][j]也为true 不相等，直接False 1234567891011121314151617181920212223242526272829class Solution: def longestPalindrome(self, s: str) -&gt; str: n = len(s) memo = [[None] * n for _ in range(n)] max_length = 1 longest_start = 0 def dp(i, j): nonlocal max_length, longest_start, memo if i &gt;= j: return True if memo[i][j] is not None: return memo[i][j] if s[i] == s[j] and dp(i+1, j-1): memo[i][j] = True if j-i+1 &gt; max_length: max_length = j-i+1 longest_start = i else: memo[i][j] = False return memo[i][j] for i in range(n): for j in range(i, n): dp(i, j) return s[longest_start:longest_start+max_length]","link":"/wiki/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/longest-palindrome/"},{"title":"Go Programming Languages - Goroutines","text":"How to write Goroutine 任何函数只需加上go就能送给调度器运行，不需要像python,js一样区分是否为异步函数。 Very basic Goroutine usage: 12345678910func main() { for i:=0; i&lt;1000; i++ { go func(i int) { for { fmt.Printf(&quot;hello from goroutine %d\\n&quot;, i) } }(i) } time.Sleep(time.Millisecond)} 注意 不能这么写 12345678910func main() { for i:=0; i&lt;1000; i++ { go func() { for { fmt.Printf(&quot;hello from goroutine %d\\n&quot;, i) } } } time.Sleep(time.Millisecond)} 因为循环变量并不支持被延迟/动态计算 What is Co-routine (协程) lightweight thread (轻量级线程) 编译器/解释器/虚拟机层面的多任务 多个协程可能在一个或多个线程上运行 子程序（Subroutines）是协程的特例，协程更加广泛 Goroutine可能得切换点 I/O, select channel 等待锁 runtime.Gosched()","link":"/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_goroutine/"},{"title":"Go Programming Languages - Functional Programming","text":"Functional Programming in GO: Closure (闭包) 12345678910111213141516import &quot;fmt&quot;func adder() func(int) int { sum := 0 return func(v int) int { sum += v return sum }}func main() { a := adder() for i:=0; i&lt;10; i++ { fmt.Printf(&quot;0 + 1 + ... + %d = %d\\n&quot;, i, a(i)) }} 闭包与Python类似，里面有函数体，函数体里有局部变量和自由变量（e.g., sum）。 对应的Python闭包方式 123456789def adder(): sum = 0 def f(value): nonlocal sum sum += value return sum return f 其中nonlocal就是标准，表示该变量不是局部变量 缺点 但是 Go 中的函数式编程因为不像Python一样不用限制类型（泛型的缺失，duck typing），就会导致后续代码会很难维护 比如 123456789101112131415161718func main() { var list = []string{&quot;Orange&quot;, &quot;Apple&quot;, &quot;Banana&quot;, &quot;Grape&quot;} // we are passing the array and a function as arguments to mapForEach method. var out = mapForEach(list, func(it string) int { return len(it) }) fmt.Println(out) // [6, 5, 6, 5]}// The higher-order-function takes an array and a function as argumentsfunc mapForEach(arr []string, fn func(it string) int) []int { var newArray = []int{} for _, it := range arr { // We are executing the method passed newArray = append(newArray, fn(it)) } return newArray} 如果想包装一下，给别人用，那就得用泛型了，不然别人要是想用map[int]，那不就得开发一个 12345678func mapInt64ForEach(arr []int64, fn func(it int64) int) []int { var newArray = []int{} for _, it := range arr { // We are executing the method passed newArray = append(newArray, fn(it)) } return newArray} 采用高阶函数的递归 借用 fibonacci 的实现我们简单地示例返回一个函数的方式来实现递归： 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func fibonacci() func() int { a, b := 0, 1 return func() int { a, b = b, a+b return a }}func main() { f := fibonacci() for i := 0; i &lt; 10; i++ { fmt.Println(f()) }}// 依次输出：1 1 2 3 5 8 13 21 34 55 延迟计算 Delayed Calculating 使用高阶/匿名函数的一个重要用途是捕俘变量和延迟计算，也即所谓的惰性计算（Lazy evaluations） 1234567891011121314func doSth(){ var err error defer func(){ if err != nil { println(err.Error()) } }() // ... err = io.EOF return}doSth() // printed: EOF 在 defer 的高阶函数中，捕俘了外部作用域中的 err 变量，doSth 的整个运行周期中对 err 的设定，最终能够在 defer 函数体中被正确计算得到。如果没有捕俘和延迟计算机制的话，高阶函数体中对 err 的访问就只会得到 nil 值，因为这是捕俘时刻 err 的具体值。换句话说，在高阶函数中对外部作用域的访问是动态地延迟地计算的。","link":"/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_lambda/"},{"title":"【C++】C++11 互斥量解决多线程数据共享问题","text":"数据共享问题分析 在多个线程中共享数据时，需要注意线程安全问题。如果多个线程同时访问同一个变量，并且其中至少有一个线程对该变量进行了写操作，那么就会出现数据竞争问题。数据竞争可能会导致程序崩溃、产生未定义的结果，或者得到错误的结果。 为了避免数据竞争问题，需要使用同步机制来确保多个线程之间对共享数据的访问是安全的。 12345678910111213141516#include &lt;iostream&gt;#include &lt;thread&gt;int shared_data = 0;void func() { for (int i = 0; i &lt; 100000; ++i) { shared_data++; }}int main() { std::thread t1(func); std::thread t2(func); t1.join(); t2.join(); std::cout &lt;&lt; &quot;shared_data = &quot; &lt;&lt; shared_data &lt;&lt; std::endl; return 0;} 上述代码中，由于 shared_data 变量是全局变量，因此在两个线程中共享。对于这种共享的情况，需要使用互斥量等同步机制来确保多个线程之间对共享数据的访问是安全的。如果不使用同步机制，就会出现数据竞争问题，导致得到错误的结果。 常见的同步机制包括 1. 互斥锁 2. 条件变量 3. 原子操作 互斥锁 互斥量（mutex）是一种用于实现多线程同步的机制，用于确保多个线程之间对共享资源的访问互斥。互斥量通常用于保护共享数据的访问，以避免多个线程同时访问同一个变量或者数据结构而导致的数据竞争问题。 互斥量提供了两个基本操作： - lock() - unlock() 当一个线程调用 lock() 函数时，如果互斥量当前没有被其他线程占用，则该线程获得该互斥量的所有权，可以对共享资源进行访问。如果互斥量当前已经被其他线程占用，则调用 lock() 函数的线程会被阻塞，直到该互斥量被释放为止。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;int shared_data = 0;std::mutex mtx;void func(int n) { for (int i = 0; i &lt; 100000; ++i) { mtx.lock(); shared_data++; std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; n &lt;&lt; &quot; increment shared_data to &quot; &lt;&lt; shared_data &lt;&lt; std::endl; mtx.unlock(); }}int main() { std::thread t1(func, 1); std::thread t2(func, 2); t1.join(); t2.join(); std::cout &lt;&lt; &quot;Final shared_data = &quot; &lt;&lt; shared_data &lt;&lt; std::endl; return 0;} lock_guard 和 std::unique_lock std::lock_guard 是 C++ 标准库中的一种互斥量封装类，用于保护共享数据，防止多个线程同时访问同一资源而导致的数据竞争问题。 std::lock_guard 的特点如下： - 当构造函数被调用时，该互斥量会被自动锁定。 - 当析构函数被调用时，该互斥量会被自动解锁。 - std::lock_guard 对象不能复制或移动，因此它只能在局部作用域中使用。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;int shared_data = 0;std::mutex mtx;void func(int n) { for (int i = 0; i &lt; 100000; ++i) { std::lock_guard&lt;std::mutex&gt; lock(mtx); // 使用 lock_guard 自动管理锁 shared_data++; std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; n &lt;&lt; &quot; increment shared_data to &quot; &lt;&lt; shared_data &lt;&lt; std::endl; // lock_guard 在作用域结束时自动解锁 }}int main() { std::thread t1(func, 1); std::thread t2(func, 2); t1.join(); t2.join(); std::cout &lt;&lt; &quot;Final shared_data = &quot; &lt;&lt; shared_data &lt;&lt; std::endl; return 0;} std::unique_lock 是 C++ 标准库中提供的一个互斥量封装类，用于在多线程程序中对互斥量进行加锁和解锁操作。它的主要特点是可以对互斥量进行更加灵活的管理，包括延迟加锁、条件变量、超时等。 std::unique_lock 提供了以下几个成员函数： - lock()：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁。 - try_lock()：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则函数立即返回 false，否则返回 true。 - try_lock_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间。 - try_lock_until(const std::chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间点。 - unlock()：对互斥量进行解锁操作。","link":"/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/multi-threading2/"},{"title":"【C++】C++11 Thread线程库的基本使用","text":"创建线程 C++11中，我们可以使用函数指针、函数对象或lambda表达式来实现。创建线程的基本语法如下： 123#include &lt;thread&gt;std::thread t(function_name, args...); function_name 是线程入口点的函数或可调用对象 args... 是传递给函数的参数 创建线程后，我们可以使用t.join()等待线程完成，或者使用t.detach()分离线程，让它在后台运行。 Example: 1234567891011#include &lt;iostream&gt;#include &lt;thread&gt;void print_message() { std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl;}int main() { std::thread t(print_message); t.join(); return 0;} 传递参数 使用函数参数、全局变量、引用都可以向线程传递参数 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;thread&gt;void print_message(const std::string&amp; message) { std::cout &lt;&lt; message &lt;&lt; std::endl;}void increment(int&amp; x) { ++x;}int main() { std::string message = &quot;Hello, world!&quot;; std::thread t(print_message, message); t.join(); int x = 0; std::thread t2(increment, std::ref(x)); t2.join(); std::cout &lt;&lt; x &lt;&lt; std::endl; return 0;} 需要注意的是，当我们使用引用传递参数时，我们需要使用 std::ref 来包装引用，否则编译器会报错。 在 C++ 中，std::thread 构造函数模板接受可调用对象和参数时，会复制传递给它们的参数，防止因多个线程同时修改同一数据而可能引起的访问冲突或数据竞争。然而，在某些情况下，你实际上希望线程直接作用于原始变量或对象，而不是副本，这里的 increment 函数设计为修改传递给它的原始整数 等待线程完成 使用t.join()方法来等待线程完成 123456789101112131415#include &lt;iostream&gt;#include &lt;thread&gt;void print_message(const std::string&amp; message) { std::cout &lt;&lt; message &lt;&lt; std::endl;}int main() { std::thread t1(print_message, &quot;Thread 1&quot;); std::thread t2(print_message, &quot;Thread 2&quot;); t1.join(); t2.join(); std::cout &lt;&lt; &quot;All threads joined&quot; &lt;&lt; std::endl; return 0;} 分离线程 与 join 不同，我们可能不需要等待线程完成，而是希望它在后台运行 12345678910111213#include &lt;iostream&gt;#include &lt;thread&gt;void print_message(const std::string&amp; message) { std::cout &lt;&lt; message &lt;&lt; std::endl;}int main() { std::thread t(print_message, &quot;Thread 1&quot;); t.detach(); std::cout &lt;&lt; &quot;Thread detached&quot; &lt;&lt; std::endl; return 0;} joinable() joinable()方法返回一个布尔值，如果线程可以被join()或detach()，则返回true，否则返回false。如果我们试图对一个不可加入的线程调用join()或detach()，则会抛出一个std::system_error异常。 12345678910111213#include &lt;iostream&gt;#include &lt;thread&gt;void foo() { std::cout &lt;&lt; &quot;Thread started&quot; &lt;&lt; std::endl;}int main() { std::thread t(foo); if (t.joinable()) { t.join(); } std::cout &lt;&lt; &quot;Thread joined&quot; &lt;&lt; std::endl; return 0;} 线程函数中的数据未定义错误 传递临时变量 12345678910#include &lt;iostream&gt;#include &lt;thread&gt;void foo(int&amp; x) { x += 1;}int main() { std::thread t(foo, 1); // 传递临时变量 t.join(); return 0;} 我们创建了一个名为t的线程，将foo函数以及一个临时变量1作为参数传递给（int引用）。这样会导致在线程函数执行时，临时变量1被销毁，从而导致未定义行为。 传递指向局部变量的指针或引用： 1234567891011#include &lt;iostream&gt;#include &lt;thread&gt;void foo(int* ptr) { std::cout &lt;&lt; *ptr &lt;&lt; std::endl; // 访问已经被销毁的指针}int main() { int x = 1; std::thread t(foo, &amp;x); // 传递指向局部变量的指针 t.join(); return 0;} Reference C++11 Thread线程库的基本使用","link":"/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/multi-threading1/"},{"title":"【C++】如何在C++中实现单例模式","text":"1. 懒汉式单例模式（Lazy Singleton） 懒汉式单例牧师只有在第一次使用的时候才创建实例 1.1 实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;mutex&gt;class Singleton {public: // 获取唯一实例的静态方法 static Singleton* getInstance() { std::call_once(initFlag, []() { instance = new Singleton(); }); return instance; } // 删除复制构造函数和赋值操作符，防止复制实例 Singleton(const Singleton&amp;) = delete; Singleton&amp; operator=(const Singleton&amp;) = delete; // 一个测试方法 void showMessage() { std::cout &lt;&lt; &quot;Hello from Singleton!&quot; &lt;&lt; std::endl; }private: // 私有构造函数，防止外部实例化 Singleton() {} // 静态成员变量保存唯一实例 static Singleton* instance; // std::call_once需要的标志，用于初始化一次性操作 static std::once_flag initFlag;};// 静态成员变量初始化Singleton* Singleton::instance = nullptr;std::once_flag Singleton::initFlag;int main() { Singleton* singleton = Singleton::getInstance(); singleton-&gt;showMessage(); return 0;} 其中，getInstance方法：使用std::call_once来确保instance只被初始化一次，即使在多线程环境下也是安全的。 2. 饿汉式单例模式 饿汉式单例模式在类加载的时候就创建好一个静态实例，不管之后是否会用到这个实例。在多线程下是线程安全的。 2.1 实现代码 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;class Singleton {public: // 获取唯一实例的静态方法 static Singleton* getInstance() { return instance; } // 删除复制构造函数和赋值操作符，防止复制实例 Singleton(const Singleton&amp;) = delete; Singleton&amp; operator=(const Singleton&amp;) = delete; // 一个测试方法 void showMessage() { std::cout &lt;&lt; &quot;Hello from Singleton!&quot; &lt;&lt; std::endl; }private: // 私有构造函数，防止外部实例化 Singleton() {} // 静态成员变量保存唯一实例 static Singleton* instance;};// 静态成员变量初始化Singleton* Singleton::instance = new Singleton();int main() { Singleton* singleton = Singleton::getInstance(); singleton-&gt;showMessage(); return 0;} Reference 【字节跳动】如何在C++中实现单例模式？@Lynn77-QAQ https://www.bilibili.com/video/BV1NWs4ezEn5/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=243ce9423fb82c395b4e9e6bf321ae0c","link":"/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/singleton/"},{"title":"Hexo搭建网站","text":"15e5c101571594c61d414e3197635cc04db40b8ec29c7b06e06e87ae55c52f607f2c1b3f83ef47740ce46abd0cbca4da32b74a5dbb073930dc1d5f92da82d4bc1952dc2e93cfbc0568d0295549d5f9886fe918b49728a921ec937df41e12a925f0f1295c7744eca35a7a118b36b73eee21b5dbf091a193abe952170ecc55c1963ff20a488b7c1237b6db157bcbbc3caac394fcd0a080d68d86ef5bf0b5b408d51d097a8fd453f2c7f93c80ddc1ba81e7746d8704b7a6ea4b0b5cbbb5d7af46ce094a7418757999fb240dff907d05166c45802066f4252062714d6bfb690690d23995aa5da5b2a5e0d68987398ba032719cc82e38b50d82e0b18c73155450f6cc91d791b90378ee9566cc3579eb87808eabe194171b7d8ef208f90e7e4629c694e3c0dfe68a792915c14a19d43f5ead2eb4630848c9ab7af6adbb170ebf78b7d27e5efe97711655e03be60e41eeba0201d9338cf5676599a6af0cd23716c8651d17734867827cfb0a0ce94d6ee9cfe0538ec508aef09f70c2beb0257f1506131afbf50b9d4752f81b36f9b712c7d8b98c2d8f1e44af81798be0e8f1e0371f2c211f5837b8ae8b60045e8b3339216a4e3faf32359d1b4434c38b608ad9eae4339ac6d72d8847b6d6b2ac8673b554387224dabe7ff443740bea8bdcf9cf923bed140936921db62b54d612e632a05724ce2345e4869b708c50d502743f4c5ca4bd441a64322417b4c9363e0c0fe60eaa5ded383530e5e29b611c2db19a091a3346a2fc8fc9e700b4fdb03f80f34d6213bfaf8a1ff8322b02f2a746ee2e9ff0b5fe11c56dfce6ba13b9df4997ecaedf14b18ca5825f80498a6fbfda84d46a62543eac62af89999c00105c24746a519ab2a2b568f03be425849d52a5a498c1b356482da66b9b4bde64add73a95a8d6b6a908ea5c5e9ded9198ebaecacde6be11485d0fd42fc17b86f91170e64ebb1e08108fce59dfdc26f05b5b13afa3ad185584189eece01bb6d13d4a99eb27b017ef4723dba6f7906dc1457f8fe22db5eada49ee5599805829ad54dcbb61c3e650628fcaf6affd64073b0ace79996cfaeaa10413a46040082181a3093bd77fce245c370086be7f6fe5eb35d2207f0b99d735ebdc9ac821e07d5eb53ff1d49c7177279096b8138c0af026e0238913fe17b97a055758984bf2ce503e1eb20d6508c72027124b0bf81d76ad49f3e46f74d3a2f5dae6ee20e9e8182814697b97010059870e7b35917aec062bcceb41ce5b5771c9e741aa3e831226e120966c3f17f51bc92797e28898fd5c7c27927a1650c3709bb8664a11ec38569f75a247fb38024d26eb5583d9e8c352f92b694ccbe48b8022ae0d70c0b2b43b4caa8bc5f3c00e0f2e27834604d62e032e6c26b862b8406ab46c4ef57d6885967721e54a87ae5a6070c6c4f763b4d4e521d720df0ae9b7bdc6645f6c07d071ceecc9553f6d19b041713b05669e763dfef6260b09b9e9e29b3780124584125f827c509882ad8f1a4d432558d95dd71e641e3e17d65684b0b21e381a38cfb917964cbd24dbe5d97f8daed31214a17648862944fadb15411f03f82758f9948fe80e737bf43e468091caba199e0d56d73ca5557676db445c16ca2bcc965f402b4dd8cc9ab96a296a7ec774580a009e193abd3b8698cee9e10fd93aa46393da2c4b5a229497c747b2b93f4c76b3164e3889c29a877fe8277ef8ea3dd26dd70d45defb3a13ed9e3b4811f8d6ea89abb7e73fa2f7b5e773c3a7db32ecb56ea1aefa17261b89ae093fe63ec84091fc650fdde27120eb68c8591f3aca7b421af2676a32ca55053eb4b6fe4f11bb5c8e08abe74ed3d617a2219f87c404b5b0b315bcadf78918297124240407f49fca5daa98f7b167f7ca3d9cd30ae452bef8b9fe3715bda940a17a8838304061e4f0fb3adf56da414ee17b8178d7b9554dbf40d72787c70ce361faf46e29f5c30f27cbe0594720d759d8de8bc4c633ba23547af72577a9d4f05123a73211ab4d026e0b31e33a8457584c627e50e5e59db4ca5cf058931afe1526b9ae44fa55ba7cac64ef561af2e170db8abc0b8452170bb7ac4ce5140cbb5e6a1f2740473fde1e21f17d7e48d84f5d0d861fd105f43804ae765cf6279c624f4e8569fb6903e82eaed96bebc0f22ae5cd0873e21beb541f40cad7d9d8dce4dac435d2a4303dbdd44b9741a585c0c56621bd7981e8cde31724b3c5f366b599cabbbbfae9bde902467cae8f6262c57e184e8d9e5a1e4a0d769ee5f95f8dd7d52abbd20386fd7609f52680df47c17bb29d481a98b1a7449404f8f89842430520b814dce73c58641988aad00aca5bbc8dd73de3e7e8ee31243ad6fb874244d8e94b454cdaebe2dea8469547d656c15143fa254f8de2cba20a0f80927cedafa58c06e6a0f46ca86164e507ab7bc6225330eac79f71ae8ef5c13e2143ae90b0502999a18ece0ce4d245b6f36612ecb931ad652a9f7ce1e2823dbf6a6ac77c038df2356eb79cf9595c136e12a845d2f9e7e4c1a3cb4450c572b5d2440a631be2e491c15c0155f79f6112b2aed62961cc04ca60334b9e3bbe8ac3501a16318d7f73ee15fc6ae84d5c2e321b297e2bd1eac24441df85d255956188c46925cbe25a819839b3437f82ed033431b5ca8694fcbce87170c4a9d05faebe8f988f8e07cd0ad965883e626f3797c05f72bb886ff2c2cb94fd9c59529e705b528e1c58ab1a296a8ba580ee2474efca22bf5f0c7b3ad2b2a944159432c0a7659150e66f59241462b55d4820f04a5b0a927a6b0b810dcbc469ca2946e3ddb35d8b3e12e94cf12137846572e87d141486696d472d3fc45d521da2862c061a4bddc0fac55db73cf2ce023239353dab328416aa73034070f741b59aa04941213d0f7dbb833bebbc89a4f03f4564be0b7c239fa43a281bf25c00c21790d91e6395d2129957c37a1e332495d0df5867414e76d14ecb14077973c479a03065892fed6221cc4682207096b708237a227b5bd76919c43966aa726ab24a7ea1ba4a9aa36103d88cd065e9641bbfe0125196f19469238ed67dfd77835f0706dc7e4b1bfafd62df60fba55539e3aed36975fe787b19c1c4647fed72b63a5448e3461521f89c7a77f6c7af1aaaf4c648388eff530c6cccfa6082bf2e2ce8217d361a8d2ba58d7734a0d746795978141ae5a9778d4f1a7ef3cbc1c0913f5bddbfa1a2de865c3b4ba5f144bd071556763969ff7d97136558b367e3b55f9aacb92f5166b24c52a4c5bf92b18774a58489ec5fe87f3596bdbd711a7686c09550885c1874e05915f1ae579321dc7a6475bc1b3e3b7f7c7aa0e0da207de821d05c68360b64d07795bb0188a3527169543f1360f7137bd8f175e8b69500939aa5ea03158e8a601b75d83f0cb895fff6d858b4c907debcc915c6bde13d31aded7fbb59a97d91009bd1bf4a9edb23718eba1454bb3966b150bc29f1d0b6beab5b86a42d672f8c74705ee6cc230c3ccadf3d02528c9a0784a170804048ee50b705150d7b514346b6acdb5b1630c71e84c21efa27df6fb5f86c8d74a96d2d4ff9c979b5a87f4fa14f1cd06527ca0cd86ab4cef28d08fe9bf985d676bb21056a90b99087c0f6a5742080d0d853f7199238e13a0adcdcc9d8d8792c5080c9d724e4c243ff6d00b870c78af5651b14a45290fa4cfa751e840a73963788742685cdca95be723508c8561dfa6c44fa1a901316cd00a35a13bb47a005f150a61a70b0d2e22ce60dbb3d1b6d01914f9e58b5233ad132a3879942497e2ef76b078a8b90b9aab4aa4f9961f33abb9991ee167e3a5b31b5cda734b0d3b9637ea0162f9d96a3094a0d505b3235ca9e8931a3c42537136b9e84fa79f0c9cba0b5a5425fb3b9e114501f0e5d82865722c867eb28283e1936f22925a525c93e66860effc3fddad65e78429e7f8751c3f765196b7939c0572c95c5d42285566b8e8274a665ee574f507f3a158ffccb2cb9d289f886f40aca15c73de59fc73cf3e2acd17f09416a99901e6f2b877c0c8fa5ec39e56d53023dde44fe2ca4c9da5b97f9f949ce079d30fbf2f2b537bb94b2086d25dc47ab21e99f08a4218dda4278fb9b1585eaf1893a3c7b70acbafa294cb04666ed0102db853851be14c824dbfe69da3786f618b36dd6fbb2fc4d3e7644a4f707a4736c98082f7e68a13583c008fb8625e47e7441542d44e5bcafbea8d56d20d01ad8e7a314d18dc3ebc88915b1e4e5ad284a2ea4d6fc379b2d357e8a28bba0b51195f9239634ed5f276fe055e40b17df161b531bc7d65ae6010aeb2972a27c922652698488374272cbde96b847b7054d2269f65fdf0578d72ca1e54f28100b748f5d224416ee85a94ee34893788e110f0171d6e2ab0f10e10e5104197bfe2a5f3ad417011888a91d1d3750b3f9f5817844b002f0ad658d0af57c80d871ed745af65d679fa41b496d95ba38f4c1badd9536872a6e3aba5c70285b1d8db1af10335027289357e52d134e5685d8d71c2fad675efe04e6ea5483097dc009128d26604035a382bfe98ba9ab3ff4faf5ea42cc57748df8002c9c1599f6589fd0277da0d59c324a803b09949f1ca842b226ccc87e3a80a37bca688f59f0e56f1100cd83ca5b7fa34e3ca026b636156c1c10e18b80dbe91d3fd67fba47c611481d56501a5dfb3bb85493bf7aee6f9b7de1450c5a979963e5be07e41ff22c693acb140f79b555bdc91d60d9a355dc790a8c5f73e85e59c5d5419917a799608de8d58acafcee6c4a822c2c8db296e28cbdba0d0438c42df74daa7b15a0b34866c5304c192d9d204fd6abab0f380c41af3a6d625e9d4329ad48ae68d06f88f9ce182a341b8cf714990e28d02dc53216697d9ae1990679a3b22839f18ab4c09f477687702456870e2fe4390ed49025f4775be22d02b988830e29affe45b2217dad1c77cb24dbf4d77a596481f8ef4a8e284584dbf58e06a6042b0ff3a3f714f9823652850e4088f5c54dfbaf9757308e2e2576fb3041831ea668463be82fc75dcbc93da3505b4a5190de252108e06edcafeba135111160e265ea2ba3c49e9509099e8026c5499f13f90972beca3a690798cad78244db67e0f544ab48b469ae36c7d83ed25242e27f1e20f03c82891a48141050493f06276a8569d140afe2f84ef6bec9a275c04572d6223ea029267851f133d910aca298b1970bbc3aa37c2cc762f3f30087ed4c66d7300e0866bfe2df5dccd58fad2ca1878e543d9a382c06fb0925bb06563cb187d10338c17926d561b6fac705d346086a567cd8add4014eba22bda5dba57d26776d91a459f4789bfda9ab2af7b14552519531047cabcdf1346e5e5fbe1e638927c8323276aaa6107ea5f6b24c0ffb1bff60f5f213e6fb6c1e9f8b502e95362d5838cf78724be117c6ecd6d11b302538177a7ad1a598582186638c198efaf823f973813aac18860267d1ea58e6b4da2e6743cee6558ae53f66619889b4e9aa59906133e86249bdf016b5f42d287a3c9daf69ebc177cf67faead5d6ad461f1e46c33f7189db2ab7ba5176ab062fb4f86428981f5cc401ac9555d047073171e89cb9682b87f18c333a6bd356dcda349caedf02faabcfc782471663175c9ecb9a9a29b690a6eadfb1fd9303909c1e73f8362afcd376add9d1f0a745fdb35efa8825bdd1b5e55552b348df72f1c4c98cf444d10b8df2f4dff545cbf14390288246c5bdcf5a044987078245f47f7e100ea4b091d71f3f7170eb3edc82decde31c176eb488c952990239b19216eeed812a7c704cd5d82b0e73bf0b75090022332184941b6be1e14dc515d458157998a66a0a7237212e34709c32f28fa9a897ec7a8c44adc8499a47fff8d20a9f2066a1a1d102e5885cfac8d26d471f146ef9333d8e7b594e6b557088fceb5eb81873c165f1e594e521f9b8d9466247715648201dae21a047369eae9512dbfc13a3d38886edd852203750c1de2ec3c4e4573a06ceb290a0b537ac7070a251428a7d71194a9d03c80e71eb589f88b179eeb096366e97bb257dc3c3d0c7061f4039eff83deb4c5cf3c877a30a2863a3bfe03571db99d8e601036bb42ea23a69342d6a8d50e1ea343f71b8a545a99a0e6e0a83f4387dd26db3940c03a2efdf711b6e9e4d8880d73f921795d698bb3efabb4208e412e7cb3807890db78549e5cd4b90ff5dc3edc24b777d6e2b569c05edcc6348b0df8ca4516ad489e924164e49e0523c8a3afecec86b9a0e1421f2497190b0a1ba3728cb9bb0412045eaaba331874914b9ea183793d35eceab66f98befe7c32d89ea6d3063c48774642d43c540d86650968d5ea3d0d806c5ac21139bac1e7178039086f9e73192d7157ead9327806f8d93c4cbefdb152803402a6f1168fee01b418464069781d634272c900c477c29f6e0c5ed1907b6d5c5c1df941693f2212b855011e401d3ca98f606acd9abcbd97563d413aabf1a83f559913b1108b1e6ddbd79ae1619dc63929e773ea78a2bef5ea4a1ca3b29ac91bdb43a7b7f0ed507e7a6384665aec3e76ed963f8e873f4b20c53820dbdec98532a58260a3a635a013aee10bd73374bce7ca983ce309c4e6ac2c0dc2b131d07d930a987cda786c6c6a8f70ba19cf0001116ace7664b005e4e7303731260cd8b9594f3dc1f1d05db39f74f7846fac7f4f1f3763fbec6dabd471cfedd668389b17fd68a816601340c217ce9d52dcc6e90203df935cd5e0f238f20b774c9f01998d3ef707102fd43024e6b3e25fab0ba9f324a1f8ce52288f1d540db721690066cedeb614794407039939dad5d0ba0b71140bacedc155edf600d8e633b73d7ff6f5406afb2ecee4d9f342a2a1998b4273158a381a5cf06b8db0f2621c5d4d4f1bdfc2fdce470a6f5e830ccea80bc2ed76778e1fff79d853734831aa3ac6007b0378336f6fb8e40ac9e72f18a9235e49616c3afb9c63cffff824a15dc7bb177e990da22313cde47c9afa106e4ac5300ccf73f1c3e5336dffa66bbc0ca679caf2f88eaa7b9f1744a5f291ab9561def04f1ebca6255b75a4af03ec9f9b8965be59bc51f42c255e1540735f993b07133cb2226ca5e23e83f5a55f428794c9f85fa7ec4816f1e87569283b4f1741f6b28210027f852ce6ac40dfb8d3d7e9c100a923377061737704b3182c0c0763542c9237b6cb43fc806b2aa275b386d5702ef6705ee75eacc80dc13082973cd35b051f8cf859d0989f3564888ce4e4fd3f560da8dec57cdb01cfc4096440eecdb6328b5599756bef7de380cd049d9248d5db0e3ffbace188aa0c3bbe9011e60807f8bc6ed9870c59e151cd17b988d6f58891a6ebd107c760d40d76f3be42608193a8bb94b6d3d9e664da21f5a6fab79d13d3764c92722758d90594bdebf36ab9b08dc76179bf87666d4452d5bbcaf363e4be41e4bb044ddae3d044d40836670fb4d344e540bc8efc58fa70d2936886f216250cf0bb95418c168d0d80c3207b8f6fd0d594b95b3219522fc83fd9feda5ba70c555f72e2ed75ef75576786f65d642cb3ba3766ee8a0f5ab2096e511109a302b867b394b36fce3825115e773feadaccdb1eef8c56e409dc5dd04c0d38ddd5b137ebb30e297cd4684d3fd809acf9d3b245cf77440a691298bb87c8add26299cecf12d31d265905f1ed2bc93b18fc689a255f4f17fca24824f0b11949fde1cd35cbd4d1503483fc259397792a603611802adbc2d7651a860b76acb24ae0c95451b2b41d3bd364327e7b8fa64f07124745e8d194e0fcde5cef50a5715043138711c45c96e1632b116499903f1628cab6828ae112bd83f4896930b7cfad8fa9f9826a3b6b2eca6f1cd64a0edde8e1d0eeea9d163d14e11750b0e3df98e105202fd59ecc9ba9d4aa55a12c751cb094f324c5ebd03a6de5751042fcd4434ce626b520bf76a59b50effc8b0a56e21ad480ca1073b2163eb029840be617e4d68a5db3176612cfb03a1c78d0c7a72976430bb11aa2a1216b161575b7e63817ad4e52f52fd4762297d1e8a768367e93fa3cc8bf36c62f5893426443027b3c64de4c52046dcd7e67f49497a24296390f77dfd8a46de65f484296e9fcf8d4d346a251d573f942a9223ee47db884e8669569f0b0e6a87c7e766fd7b2fe56e43114989e9bfd255aee06bba068da05f664083369f1ee7a3784b44ee82bd5c4c62750f04c83183db7ece08e9002cb309fa2f8f19e1804beb296215d3c708ba09b275a17018fc2b161b63bd0f0155d63d7f73eee05718823c14f3dd8caf1e754914b4cd87b3a23135a09eec38a0a185671973643971e435c5633781458675f05291407f5ea0be19a8e6a90189f5f605bb52590ec0b0347e32df3c932f144fc7cc2ac97c5037cce94e4d4e802790d3cebb0b1873f835361793bbebb10cb880f4968fffde378bf2a661d1690c0a87b53f6ab33ff30453a03421a760565264534824bd127bc7aafda026ab348037cc1404cf709c622824ae562ff3ce10935fbf83b890e83b3b9f394db65fa37362f460ca67ffcd53c55e9456e85f8fdd8a6dfefb79762eeadc51f9ff70b920375c4242ade3bf9a86c673a5286a6222a4ba527d521f0561ca7991499f7dc21dd6bd4a4a87efacd0e0a4f6c760270a2ca3e534e0599d7df3965b685843484d17a586237ac41a5576acb69d39bde2731e5e01daf595f93dc732b551795d0f243e799499160e58d55697899f12a67c6e3b1485d43789742793f9d350fb5497184b28d19596a4fe0f290221be51b166fef8d49d1bd5fe0f67e9c40a4ac3cac12f81af00bed30fd27aaf4dbcec9f1f69e4082f59ed4fd21161ae5fff481a45edfde78aafbeae3ee7fd3548324fa0d5dfdbba0e0d9238178126f65e907ae0cef3bac2a4403b4929ef52974fb749d2358dbe870444261a1ebd541c7fd3d318eedebe49448b3697706c791562af717ccec2e63ed80dd3e97a0b3aa9e20a27a9a4c6801e86fa112b8539dfc67efea5f7b64600598aa22dbb354a5fffd45d9c6575eadbb1959693fcff61d55d486d12db39ceee65e30945a69904113aadfda26894de2105420905963b98e39bf2675295956c2d68f481a8cd795757213dde97dabff53d8a90064a7455f68ebc482a51d2eeec2a33d7ee348c1ec364ea46846f59dc387a2a3f355d732c134cfa5213e1292037a4173b979b2573bd640f937bd232d0fbd2873df8f5a2123806831d907038e58c85df3e9685a0f508cc986eef97ad452070b653bd57e286b6df4ea7095ed260014c1afba1b2f445a3cf9d248b9c7ca8af73eca4923e298fdf9c8f991c78918e41e9a4db887f919a57c8d9e758dce4487cb001a0f2ba324e2a5995b9aff6d2149413ed41ac8a4480b28eb18aa4e94cb8318cd9aab0157d56ec945d0db175f43fddfd1efc4139db21c2d5272c0f214e8ddce05d4a59f6005998c9f7ce981c6c30efc430e1e42e5fc89347884e0b0412511e939e84926b7a341b3c296dfe695ab52531bee16c59937c87f98609523636c0579d7f13177ce7bbdd60ac844653227f301e9746bf3deb203d52ece17be027c6b5b6b3657de505c0d89b9fdcbfbae69e1ad6d6f2eca925e2a3e0d47aa87196f4d478644fa40be0c98a40aed8434298a2b7bf193897cc9f798e5ebaed04df27d26f86f6bc86cf202a310dd759cf9d61c27d3228610f074a7a531498bcfd62ee7de72a0fd6b67ff3d3ced81d5e60e2f26d3051f0d71d65d06221584973278e5a0e2062523a1bc552f7673c2343aa3034ff6e7e69d7023cd41306678b409d51b123f83c24edbac0fdfb2412df107b6b9029d31828e122797873b6c2598b830118d4ea4981683c295f893f0f037a55fe33c41cac1c458a7da98b2bec63f357168c5f1b7a7192ea8089a80d6139aedb2ec218facbd92f4d28592a0f2420ecef94efb47ff6b513e761ce4c857a5e1d356b74e8aeb982906789ba5f431c33da9e905940c8ffa747433db4a685a999e8fbc68dbd3adf117d9eac191c49b1ca1138e103939f152099018ddbdb8f990f59a02a13ce09099316c403fd082013a655312afa98494539f97efc92504084bebf317cfde3ecee54ebed506200b2db16ecc0ea76708524f4641dff1c937f6b68fa71b2a4795f4f2854d67418063a4a4ed8822c92c774a53c906bfddcd78b3317f14ea85df8bbacfce7662ddf2048d251f8a40081196ced8386740c2669eaefdd878773e4e9ea3132dd02e75e8348caba452a18f0da6b87f95f3c372ccca45cf9f4da70d3f075445cd14432362ed001cbeab7c659669307593a42c351b0e846bd239a8aec206040d4d633ad74566159b7262e0eaa7421d3d0193b2cb57470420f62ae3d191cf41d70ee5e05c8fa451e6436c6f95ba0d0d1e175ac93492c1173726a2cc0fec25553c5dee6f937019733053742b5d1f2697d807dbce4bf961cc777d1ddb80c0c98f44152f98d915d39d92c2e708405af7df650a9be2191c50d52bed7522faed2a85ea429568427655e17814ff4ba33ca07c4c2920cb559fb54490ea9e181c0fb6027129b64895ae226eff97c50a9d8369f6f9b9b21612cba8b775659d763f5b81179c3d4bfefcca25d8d37795db75492878ff903c43c9112a52555db926d83f1c94db5652f91bdc498899f092db92d7382e97057d2c30e10c6419222eae4390ad3df4d31d2eb41dab841d3995c6be30d3f370aa91b36d9e834174684ba8ffffb9f75a42f480974f34b33c2e859aad64138cf678f32f699b42fcd98646b0576d1f1d3dac83bcd13f9354d7b222e9712a3ff591e14dbe724e87a88ca790bd89b842c1940b39c25e0054540460e733af59d01559e901005f64eb073f6a0b61685561683af4a489707373708ae708a5cb193d6ca930e9b31e0c46e6813527b4dba9bb67c38adcbedaaedfb36e05f46c7840c5b762727086780fc6d9d96c9291f5e5634879309baf94c365438ecc09cb4c116c3bd37fb90eea417624a923b1b63e76e5607772a883a948b0b4060403daa32a2885ba6e8e005c9889d198f7c4fdc44500750b0a91836ccbff9619bb42228ebb8118d7e82fb4348076393e387905e3b1d77a7582316c6047bf338b22b2e2d2fa0c8b32b2b6a69199873e159a5ee94d36c1f0daea93702cbe523af848f347379ec4f23ca45dd2b891ff5a28f4024e9119052f1fb218ccbb504af04c072d70b51323f6cc5ee66906d4b29bac5bc94857e5dd340676c14542c1de4da628553cd70a136cbe369c7023eb15523ced11028d971e6c8cb8a3f25d1169e80cc9a6142c85642a19b40540643d366363de77db5cc0451442cc3e3da381c5821caaae6b92cde61790842aa9fabd3741df27b4fa3ae478573a729cf7483b47509afe53c657877941163d0ea842e7541baf895f0f5e5dfda330dd21b7d1c1291d3a8f32d6cf687fef4b5318ccc7502bf7f96f497ad2815e41563ac92c152f46adf886c310034e59178cff2b77dfac153451de42fe2098a7d36629b9580475aa44a45bac90126ec688616e0310aaae5e738e50cdafd8058c6ac572ef42094f7ff9c8dc1b56f1ac57dc66c0dad6dc88ac0d23a5f19385c9f26600ad1d806b846447af23022874e13c0298587812c10a3bdcc6c9bb75f3ce2a20e6ca802ca357ba06958c2862c35dc38873421977115bfbbdea4c2dd2717904d41c2cf50951563ec6c13b67dd865f22fb8cee6e432e66685125d24bf278627b177a64c1d46275fead3878624d2f49c64f659366ae447606e8bd7ab07b2faefa6f0868579612dfe6e91e4c683bc85395d1a946aa0f98463191fd0f412ead9cdd7df4f86c07efbbbf27a0fda55850e68f398ab8f3e868a78b01d576e704e7cc1baee20dbac43da66ec96b7bfe44c559af8a2b11bbf7afba91fd5bc05149273bf9dc6edc040de7c96d24aaccca15ab7838fadbc02b9a15daf20fbc142dacfbb3c6fb68e330a1b9f6312c394b3fbf80eeb9175d73836e8b3e3cb3058ea6210c302ebece515810a11e4e596f248456bb6cb185179e9bcccbfdad99612dc563485ac559cce23d8d52f4200adbb97643a5ca8df61da550309d262ec30b44808c98c569808ecc09604f3ed1c928b53a7a38be1ff31885594c973749fc0e61eedf74e3e9b04776ab5040db4ff5efa1027e378bd3875e5fd53cada6972bd16b8a59c931f62a51520a38878fb8b6f13719ac6b1a495b6c45ede130c53b53054f0e5c921e549601f9b18138a64587ae6cf08d1a491db4a1d684a83189a30cad7ab2d3e0e2d849c4c321396e8641cb98a957f4e5a29ea96da2b942280971845d14cdfffb61de5978c9b58d613d2847226004ae88a84408d7aa5d2c85965a67a7d79b46930d92bb3e049cb787078bc568db7febf684bda0e9307e49edf7904c92e6e0c9cfc7db6ddebd1bd3a2ff4c8dfafc129c9dd7be01fd65065f67240b0cc8c8e5402a846624d4ec2e22646596a41140be0f348efd8d47e85ee578e0e32814fd00e19a45393dd7e3c2ea8c129e3e2fc73efe7a7ffc2f2838c4077abfcbf34e16669fff6bb9dd00ff89f0fbcf340b9485facf2ac8194659c13b208ea56ae63606b8ccc9cd03e558840690f1f84da1ebfcb74aa37684132187e65c0ff29ae21267185ce487cb82b96fb5808aae43eec424f12357f19bb0d48bf80a8bf1c9de262ea7868ccee255f88e5c6aec8915469039336183e0793200101cf54b66d7f6650cc1be27674721f43ada69f75dc7fa60f1ce1a76cc985f4d232c071d8abb40688187d65040ccfd2bc66054eeb4f01699f8811e3cf117fa303a0ee3802a6650831fd533de54927e00f10d6990c9846f84258748821753811feb535457db1c53eff08e36a2719077396af5cf466c49c6ae48f9b05b7f7b0d695931738a4b1648ff2cba656f491b262a8ea7655f590522753a3c8d5b7ccfea5495e59bfa11c3bef257ed0dbbde87db223db583056bbd8e614753fda9d0119281c6c352f3bcbf3ad7e427d82b82c2f3d06e652523ab5bf3f06838031339a8edad4974ccebf621fcb7ab0acf72af7056d8951fe354de2150aa1396ed7ee8b5c26de26125ec4feaaa9a45d37334ef3868b49507a5a0b394b5bea4535f9bad00ad755713eace2afb1607199851f2dce219429b10070d2280eed1c11b6fe1e5ef068b1322280c8e353e45f750091f72fe38e26667a4191bb42f6198947db52e34e8fb3bf67047eb3e02b5afc3a173cf27f5fa919341ed94c579f910389a35009bff24e4059ff013108953e9535b8074927406aacf49e8762aa214e7f57205ce6cffbeaddbd22ed567e7753f185794d7d68f51f9fd0c3abf01b92ed7836f547a5adb9bef667bfa13e72686141ab7b60cdcd5c42f906d2eeb5e43b59191fc79cd8b9440686e1bd89038ea648b9ebfc1ded61d5684a440edc1ce667c8ce30650dbb1544ee4cd64b8ca21f63549b5c4dcafc23c00de04741db652799ab5ebba4fd4a50c3524b75989520e37bdcf5101bc1ecb1c192da9345d24bc8db00dd245d3c5ecba33c43fde0004eb054b4c241860062efb0017bb13072e828f23ffeadf26bfcda0c020f8c153f17cb0567e635ae09286fb399264d4fdb20c0992f158d2b4a3ae4b8f87388ebe804bf429b2b8dde47e95cb283ebb645abb2f4c8a97d4d66fa1f01c76a3c7dd37b7f350083f851e4656be9e64e7a8b164ea061d590afe42b1f85fbdac2bbacabb5281f444b3e9fe6814a7e6c2aca3e792229ea23257398ddd8653261b52e444b600d6120ebf7790153d599e55a2c1e9da264cc4991ff7bb03c4599262aa0b98c020f2a99ac5e94aa938cb9984fa409ce8bda3d5cd376d063995822ec1736c49df4b5fd83a44b9862f0912b19a8bfa38c4c90fff691b58cd3d2914a5f4409ef932b6458b4c08309b9d5197d21da6eae03ac9f251757d836ff60b81a9c928268928f39aa10eaf74df2b808a725a911d4ade83701b9d8cb218ca129c2ec08b27b2a3eacb51eff0dd464df160ea20b5fbe62e778c628424ddf8639fb3b619e69d5127d587068f0a6ec18c93c9418fb1a822a51f5f210c03f21c5ebeb13f1f87e6caaf4b436961ea69722c1de3aa1f3b4d2a11f9d1a569921791eddd5a164fed57803a6a079b8a4316e95ac0ba97ec21ed8a61dbdd0dc2e70fff581804760ef5427a2a89a06030abce039043897fbf4c598864ca0488d509f20e5011d7444c7ebff48d2ade8d1db2842686db05268869c1d4f4f669c83d4aad27db2252318019800b8645d437131854f435599fc99d4b2dd2841c2944986ebc97369e5cba40e0baeb658cdc1850cdb17030107689275250ac63d8af03cfda6613652932df05d17e93a07dd20d81679120381f5c2fc80bc3e7603da15681eb875da43ee65aecaede3a0de3cb86a7e3f7a150029a09608bc7d12eb4701cea867e1fb75d5b5899781fcf42c173c90a1d991368992c8a281ef238a6a0f0c83994e47c57d1e27f63e036769c8a372d982aaeb5bee7a6e1c32ace86682e713420f6a0e72994becdd86d923717533cc06d19f31eaf97b1619b364c84f64e13d5bbbe272ee08ac891c906e871b37187294c3ef26bc14fc5095c9ab8e19245a6144923814e50482d3d605825907e05851975fe2c0828fc085b7ddfa392017c27cc62ed170393626084144563dd117fb6264542bfc1a4fff148c5d436a00d74c6dfb063c36cb98564aeb651c0abeb28dcd5367a387c5e446e356209bf76f7cd9f058a068b1a0946a43de6cb35703108b44397a0f2cf9499fa6099d6ac374c33332eb0696bacc0634641edba3256a75c4f949b2068e4535d128be629938faa15ad027380fdfedee82ccf2ba9770f176144556a15adf669ee0fbee743ec6950349d817fb2e250d5f56d0cfd1b802da03e2d8ec626f11ec253185c917e0d858175c42be044f60339622a7ce9340b3ff62f3d4fbb706ac884b91884c44768a5ce9be02868cefe15c63a2752d126e52633aea2c7ff46825eaf80670a5b2bddcfcc6f587deab09fabe40ef4c538a23fe19fea9fa454759ee11e26eb5f2e4a86741d715ec7ad3446505b66591b501e96f5a5c853cf0bee886fe72bf4e50e2dd959de1b3d12338e25214934205d208ef2eb959c4c6deb30572db01920e8e1ac1f6136a447028b9cc694d6d817e328cd9dde0faf4c40f6c01552ef9fa717a9d13ba5ba0a028897cf3ec772c11145b7a16bfa2babd4030541d843c7a39dbafafdd9371f2b79209d5987cf27b76c396d52a6550589da14e4325f8d99638d77a0ddd7b93446ac5580d25c43a7e2950f39f9a3b13bb8529355741617fde5bbf26d45924d33dab1f923452b10842970fc5fdc55b7485f380b9d9fbc024076df8be8df4b44338bee1ea2f2efd85b979ebb768f26c0c472017a8a0ce7e6c12aa73b72a84c788afa98d90daab6fdbbc4b1a842bc56aa64d35f0e07cafe9845bd2167f1898a0d82bf1c5bcff5c1bb7cc4ad93e74958a52ee30e90316691fe5851976fd096855c0ed6ffb2075598fb4e0a6591c86874ebcd53d01d3710a5b630230f4e141500cfc3742d8d3c32dcb66e5adc6a018b780c308656daf83bd4490dd61fc1553e1d49c81470238713f0a142bfd646011d8cecc263935b9ae466240b9ce174869aa7c1dbe903c5078146b7488447f335f12c6c12195eb9115c632040996f5d097fc65e786a98f453d6107894eea4b4ccbbe7a8f7239b2f28dfb7cbafce72c494dd243df097719cc0298d29f186bb35f5ca1026691d366e0849f5f650914a70bdab8ed2c5000b2dcde8e258fa8a61e5015a6b342543302253369991ac088a03f8f581720242080a0d3fa33e8cf8a7b57fc4c4eb94c544755d99bf5227cab2b04f737ae87ec800277a0077328f6458de9644346e8f9f9ba8e0cbf7c080450c6557127a06f1fd57b31960af5cab6c84fdd43b3371f4534379b4045f4489d29986860e450cf5871cad77c1046e44edce9ee82671dbe4bff01443092d19e64fd283bd5dced539c6386468fa35cf433d67c2e222efd9377dad97d841a35c371b9efd9835989b420dd8b56fe199bb2a13e8ddc1626249b1220ff5ac48224f8ae172d3849c9505d10931c306d1c6248f2c2d67ff88fbf4fa7c3e2f0062802e618f85f257a2b9ca9051f0c1db612492b185cac7423bed2f73b750dfd9339e577eaac3035bc3d5a5b5cfd31fdd8aab5175dabeab531bca7c4d69b60daa87c6bf78f68b65749df7f7f54e429cb8a2079d9de4ea63e65fff9f2b4d471de6806e005864251ae969d38538b991e1ba24e3580449d17d10ba1479b037cbe8c08c46a88f5650df5c70220e7fb7d5c09cfef6a0fee6dd53f48e90058190a1fa0573f9b8cd1ad1b89eef7d2faab1a775e1cb386db0643aac1e2aaa44cda2d7cb6dc3801daafef37199dd2aa16f492e831deb7c7ddc9a7e614e64348f3e5ff3e459283d9999cf4afccbf6fbe7cd133eedec7a37be14cac5616867b584e7f59de808bd0034d01f34fc5636b22d6381fa2ff6f1842ee375709e4e3a19e3241f1a909880b936ae601a851eb843f6dbe2158b53f61e23658e164f34120667a49bb625a4c1fb97dc469a5f6c26aa30175178ccbbbf5d45b064ed893038dc94202945ca219dead876e1d2e44a019ec4e93fca344109938abf49e337dcfb4a5ab6570d256bca3f4a4a3c54a0015d5f40bcb15b41d02fbe50cef74555fb5eb92b0b8a771f4683a56339bac85b8b3fd5a4dc4d674c9f5303e17b177be6408370c4e66f2a978dd08176310127b27f0b8135e52dc291e1bdcfc9c16ecdd9ddecae24064bf7101c65211f6e4a1f85af3785d3dfe253bcfa2f5b01d45f3e8dc7eb89efecd38662f9f19775d55d6cacdf9c7d5cb2c156e66ccad3f3fb8b7d2ea30f4cbb0f61a8cdbab1ddd008fe55a5dd6c0f1be308ecd3376a2a8f5b7346d41e44ffde79925f13cd13ab0e5ff4feb5ba4ddda7ef26d10e626cfd53452016fdff6c4dbc16b6f20020c679652cf8f9259586d176ced38581a6f906c79406b6f3c5495f880a1473203776a7fbd07c45a0dd3feec99ad8770a71567b7d69f01c35c968372b9f7a45ba8cc45a4949110d16620cb261ffe9d691ef03de5d5a68e20d45937d0e5e8c6d619bafe511ec074d3fb424e4d18bae42573169a2ccd50b730ecc04667fa8df0ab8b82adfaf8569fe86ac3c2cb2bf30e797be7605116a52f13680ede582891e46755ae4e3ef9fd87ef8205bfedc79f2d0c5e8406c8d6217af62422e1ec1a503d449427dc43ad92c9dd7e77cd737ac6b90bef5a0e418308307524860cc660c76fd3c67698e4536fcc5f5f39cb1615405bda5e700d23c7e7bdf86cefef37c0acfd8a87eb209db09d02a7c6324bde96dff1276dfc5f3440312462524b0d122a9a7bb3ac104dad398d0ed17026578d7f25aa37358220f19e0b6b42756e3e25905337313b27b077f6f42d5d6fd03c4547151e207fc1ce2d565d9563d548c09b25725ff4d7c4eb6f96cd327a7f38c15547ecd84376912e86f383d02dab1c89f4af0495537dad2e9cf58e41100df9baff078ff74d5af6323f4f827f78c776bd191de7ccbd764e7115b3993dcab5e926a108a138c0a02b385777f3b65edd3d7ed9e1ad640319e359dbfa336baf4256566b47b674207040749855df1ded1b34afe64c7471cab410dba52b763b863fda0a40b6af90f1aab5ef90146b729fc04935df41d8b9c087616feb309153ef679e0fefafd807e0deecdcf3715f052f45d8ffd51f3e23aa5c92fc71ab66b60ec67faea64f41ed61b1c2cc2c9ac7333e0c0c24c7a2a85b408655fe3e4d1c1f7c2a7be3b97f73a4e9154e81d8c660b5b7c0b3d9de987bbe04665ce2325f7b834b40cceee1ba68dcf857cb8fa992a6dc10e4720477afb08d56081d25d2f0bcb5867a47ef57d2e23cf016c19aba8b11abdb5e7f10bb22ae745d2bc2720382ce2259049d0d8d099d6333744f857a76f20edcac327ecaaad0971cf9e6f354177cbfc7ed64896b9fa09079d7a69aad28bd0e1c7e089a9000cc9a18efb5f083f0379da31855ee59003a2f02a566992aca0b3c87663ee01191519af21bb3028d108e994248a84d6e5210520fa4d79ea156b7bfb241d4957c120e8defbb9e29c419e7ad0af8a1143041c5cac5adab345e9a789e6e88c051d4da7bd252d6b2f42cf37a374d01ce567b5cb62873d80745c8efdfdab6d6ed4bf1c41b3c42e68c5418228ee827ea133bc314126d62cff6fdf9876c35445c885626d6531872bad138d0aba1b63804badcd31da48143504c5e86c01588ad587429045cbc090e7f7173ac1025591232ef63c43ba68b137036b3614c201ea0d20fbdec682401c27069e336b1f797b42f4c575f284507f61f280c0ebf8884c99d6fb195baa0ea8ee22bfd96ccd1d3f3d9c86b28c6a7c8de60c7753252bc919be1b3c999bd95423110dbe5f71d1ee5b8959494db66f4034bb68fa0647bca9f7ffcef287be0b4422398b6601720161d860110b4db799924134341dc7f03b5ee9401662ad13ad28242cda14686e63ba84a613d7654b7d74dd87e3d8033a6bc67fac5a1909592e3187750d08a4f3b9292a2d5f0268c9c693e159642f43b4e75395d49b273e70d33d9ae19fd9102745c0d94e9c6acada9d64824532e68ab7607338c3fbfecf6f422cf4c5a44132c93b2bf7b0b019c0bcd55b12fca03c17ae239729832beb4c2f00414ea7ab4cb5351564c9559589f34b3c4e2acdae5ff1e7074629a4a3ef98ca6d7e490ae2e8ed9fa08ba300a1774729e8f735fec13dc01864375407c95d19ea7d28014f168d7ddd7708eafed8d5baa1e4b89ebb45e66b34712deb738dde48bc997d1175ca6760f2362b8d9c235dcacb8b6a3309d11932deafa7e186f2ee2e3b5c753d57c4076b98faa02b756875f9d8128ce0796105c508cd6e4c4d9760cb01cba74ceb0536bcc2e379d0b302a22e2910d6ca28b7a1a0c8ed7472df86cb8ebe043cc37058a700c03139a4c8751e8c1c341109401c564e529b2ca6fcf974f10556a3d77579c60e02562d3f648bb1650836bf7f56a2800dcbbc39c1e424a4aeaeb34dd3745f3a64aac96cc41dd59337754a9dac3fe9e70e88860e1c0184dd8694b1e4fddac59091dc7b781c12b71e09a9f083f7ba44a7b642d574ecbad37f052d8d8312c914c0846eb8ead55f97a8cf245a2d1e77715d2366ecde0c5426d309e3d597a8c9695bb9d8562ca99a53e1b81df3dab0ca33b42c1c89296b8d0cd0b5bf10b10e3113eff70b614468f91759f670bfaeeefd308109504b46935994f9de0883e 请输入密码以访问内容 Please input the password to view the content","link":"/wiki/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/HexoBuild/"},{"title":"Go Programming Languages - OOP","text":"Go's support about OOP Go only supports encapsulation, does not support inheritance and polymorphism. Go only has struct, does not has class (like C programming language) struct: how to create an instance 1234567891011121314151617181920type treeNode struct { value int left, right *treeNode}func main() { var root treeNode root := treeNode{value: 3} root.left = &amp;treeNode{} root.right = &amp;treeNode{5, nil, nil} // unlike C++, we do not need `-&gt;` root.right.left = new(treeNode) nodes = []treeNode { {}, {5, nil, nil}, {6, nil, &amp;root}, }} factory function (a difference between Go and C++) 12345678910// we do not need to care// if treeNode here is a temporary variable// or variable on the stackfunc createNode(value int) *treeNode { return &amp;treeNode{value: value}}func main() { root.left.right = createNode(3)} Question: was the variable created on stack or heap (a question that is important in C++ languages) Answer: not important! The compiler will decide if it is allocated on stack or heap Define methods for struct 123456789101112// the parenthesis after func is called `receiver`func (node treeNode) print() { fmt.Print(node.value)} func (node *treeNode) setValue(value int) { node.value = value}// if we want to usenode.print()node.setValue() The difference is, no matther what you decide: treeNode or treeNode *, both of them can be used in struct methods as needed. For example, even if you input an address of treenode: 123456func (node treeNode) print() { fmt.Print(node.value)}pnode := &amp;rootpnode.print() This will also print root value because even if we pass an address, it will convert to a copy of the tree and then print it. The compiler is very smart and can convert according to the definition of the function. The difference between treeNode and treeNode * is that the treeNode does not allow changing the object (it creates a copy), while treeNode * can change the value of the object.","link":"/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_object/"},{"title":"Go Programming Languages - Fundamentals","text":"Table of Contents Overview Environment Variable Basic Command Go Fundamentals Hello World Input from stdin Variable Initialization Explicit conversion (强制类型转换) Type Basic Types Constant Initialization Enum (No enum explicitly in Go) Condition Statement For loop If/else Switch Array Initialzation iterate over array Slices Difference between slice and array Iterating over slice Map Create a map Traversing the map (using range) Get Element Delete Element Map's Key Functions in Go Typical Function Multiple Returns Named Returns Variadic Functions Defer Keyword Type Function and Returning Functions Receiver Pointers Pass by value &amp; Pass by reference Reference Overview The go programming language has the features in C, Java and Python. Go programming language is a grammar-sensitive language, meaning that the language attached great importance on grammar. Go supports gabbage collection. Go does not support inheritance and overloading, but supports interface. Go supports concurrency. Go does not support casting. Go does not support assert (third-party packages available), Go does not support static variable. Environment Variable GOROOT: the place where you install the Go GOPATH: the place where you store the source code src: source code pkg: dependent package 国内用户建议设置goproxy: export GOPROXY=https://goproxy.cn Basic Command command content bug start a bug report build compile packages and dependencies clean remove object files and cached files doc show documentation for package or symbol env print Go environment information fix update packages to use new APIs fmt gofmt (reformat) package sources generate generate Go files by processing source get add dependencies to current module and install them install compile and install packages and dependencies list list packages or modules mod module maintenance run compile and run Go program test test packages (go test will scan for all files ending with *_test.go, so put test and src files together) tool run specified go tool version print Go version vet report likely mistakes in packages Go Fundamentals Hello World The first and foremost thing for a programming language is to understand the basic hello_world.go 1234567package mainimport &quot;fmt&quot;func main() { fmt.Println(&quot;hello world&quot;)} Three things to notice: package mainindicates where the package is in, this is the entry point for go programs There is only one main function in one package import \"fmt\"indicates importing a package func main like many other languages, the main function However, the main does not need input arguments - like Python uses os.Argsto obtain arguments Input from stdin 123456789101112131415161718//take input like scanf in C_, err = fmt.Scanf(&quot;%d %s&quot;, &amp;x, &amp;y)fmt.Println(&quot;You Entered x:&quot;, x, &quot; and y: &quot;, y, &quot; Error: &quot;, err)//take input like cin &gt;&gt; in c++var x int = 1337var y string = &quot;string value&quot;_, err := fmt.Scan(&amp;x, &amp;y)fmt.Println(&quot;You Entered x:&quot;, x, &quot; and y: &quot;, y, &quot; Error: &quot;, err)//take input with white spacesvar z string = &quot;string&quot;scanner := bufio.NewScanner(os.Stdin)scanner.Scan()z = scanner.Text()fmt.Println(&quot;You Entered z:&quot;, z) Variable Initialization There are two ways to define a variable Implicitly initialize 12var a int// equivalent to var a int = 0 Define initial value but without stating the variable type 1var a = 1 Define initial value plus variable type 1var a int = 1 (new) convenient way without var 12a := 1// equivalent to var a := 1 使用var()集中定义变量 123456789var ( a int b string c []float32 d func() bool e struct { x int }) 编译器智能决定变量 12// only can be used in a functionvar a, b, i, s1, s2 = true, false, 3, &quot;Hello&quot;, &quot;World&quot; Explicit conversion (强制类型转换) Go中，类型转换是强制的（没有隐式转换） 123456var a, b int = 3, 4// wrong, math.Sqrt returns float64// also, a * a + b * b is int, not float64var c int = math.Sqrt(a * a + b * b)// correct, must explicitly convertvar c int = int(math.Sqrt(float64(a*a + b*b))) Type Basic Types bool string int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64 byte // alias for uint8 rune // char in java, alias for int32 official：rune is an alias for int32 and is equivalent to int32 in all ways. It is used, by convention, to distinguish character values from integer values. float32, float64 complex64, complex128 Constant Initialization Full version 1const a int = 1 Without stating the type 1const a = 1 In Go programming language, the initialization cannot be like the following: 12const a int // not legala = 1 // not legal Enum (No enum explicitly in Go) 123456const ( cpp = 1 java = 2 python = 3 golang = 4) For simplicity, we can use iota keyword for auto increment 123456const ( cpp = iota java python golang) For more advanced usage: 123456789// e.g., we want to create b, kb, mb, gb, tb, pb...const ( b = 1 &lt;&lt; (10 * iota) kb mb gb tb pb) Condition Statement For loop 1234567891011package mainimport &quot;fmt&quot;func main() { for j:=1 ; j&lt;10 ; j++ { fmt.Println(&quot;j&quot;) }} here j:=1is the alias for var int j = 1 In java, the type can be written in the for loop condition 1234for (int i=0; i&lt;10; i++) { // statement here} For go, it does not allow type to be written in the condition, but you can use more stupid way of declaring the variable 1234var j = 1for j=1; j&lt;10; j++ { // statement here} Also, for go, there is no **while** statement, meaning that if you want to do while statement, the way to do that is to limit the condition to just one: 12345var j = 1for j &lt; 10 { //statement here j = j + 1} Others: 12345678910var j = 1// infinite loopfor { //statement here j = j + 1 if j &gt;= 10 { break }} For also allowed for three ways that substitute the while ignore initial state 1234567func convertToBin(v int) string { result := &quot;&quot; for ; v &gt; 0 ; v /= 2 { result = strconv.Itoa(v % 2) + result } return result} ignore initial and final state 123for scanner.Scan() { fmt.Println(scanner.Text())} ignore initial and final state, and update condition 1234// equals to while (true)for { fmt.Println(&quot;abc&quot;)} If/else Similar to most of the language, with a few exceptions: Can exclude (), but cannot exclude {}, the left bracket { must be on the same line with if statement Go doesn't have Ternary Operator ( x &lt; 0 ? A : B ) 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;io/iotuil&quot;)func main() { const filename = &quot;abc.txt&quot; // normal way contents, err := ioutil.ReadFile(filename) if (err != nil) { fmt.Println(err) } else { fmt.Printf(&quot;%s\\n&quot;, contents) }} Another way to write this would be: 123456789101112131415161718package mainimport ( &quot;fmt&quot; &quot;io/ioutil&quot;)func main() { const filename = &quot;abc.txt&quot; // equivalent to contents, err := ioutil.ReadFile(filename) // if (err != nil) { // ... if contents, err := ioutil.ReadFile(filename); err != nil { fmt.Println(err) } else { fmt.Printf(&quot;%s\\n&quot;, contents) }} Switch Switch statements in go propgramming language doesn't require break; they will break by default, fallthrough keyword used to go to NEXT statement even if condition doesn't match, fallthrough is like a continue so statement that after it will also executed. however a workaround is to use labels and goto 123456789switch var1 { case var1: case var2: fallthrough case var3: f() default: ...} Example: 12345678910111213141516func eval(a, b int, op string) { var result int switch op { case &quot;+&quot;: result = a + b case &quot;-&quot;: result = a - b case &quot;*&quot;: result = a * b case &quot;/&quot;: result = a / b default: panic(&quot;unsupported operator:&quot; + op) } return result} Note: Switch will automatically \"break\" (we do not need to write break) fallthrough = continue running the following code without breaking Array Initialzation ways of declaring initialization 12345678// first onevar a [3] intvar balance [10] float32arr2 := [3]int{1, 3, 5}arr3 := [...]int{2, 4, 6, 8, 10}// two-dimensionvar x [3][2] int iterate over array 1234567891011121314// first methodfor i := 0; i&lt;len(arr3); i++ { fmt.Println(arr3[i])}// second method: using rangefor i := range arr3 { fmt.Println(arr3[i])}// if we want to directly access the valuefor i, v := range arr3 { fmt.Println(i, v)} Slices Slices are of dynamic size 123456789letters := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;} /* using make -&gt; make([]T, len, cap) */var s []bytes = make([]byte, 5, 5)//ORs := make([]byte, 5)// both equiavlent to: s == []byte{0, 0, 0, 0, 0} 左开右闭 A slice does not store any data, it just describes a section of an underlying array. Changing the elements of a slice modifies the corresponding elements of its underlying array. Other slices that share the same underlying array will see those changes. Slicing a slice changes pointers of the underlying array, so it is as efficient as manipulating array indices, size and capacity of the new slice are changed too. Example usage: 12345678names := [4]string{&quot;John&quot;,&quot;Paul&quot;,&quot;George&quot;,&quot;Ringo&quot;,}fmt.Println(names) //[John Paul George Ringo]a := names[0:2]b := names[1:3]fmt.Println(a, b) //[John Paul] [Paul George]b[0] = &quot;XXX&quot;fmt.Println(a, b) //[John XXX] [XXX George] fmt.Println(names) //[John XXX George Ringo] Difference between slice and array 12345//This is an array literal:[3]bool{true, true, false}//And this creates the same array as above, then builds a slice that references it:[]bool{true, true, false} Iterating over slice 123for i, v := range arr { //do stuff }for _, v := range arr { //do stuff }for i, _ := range arr { //do stuff } Map Map format: map[k]v 123456m := map[string]string { &quot;name&quot;: &quot;ccmouse&quot;, &quot;course&quot;: &quot;golang&quot;, &quot;site&quot;, &quot;imooc&quot;, &quot;quality&quot;: &quot;notbad&quot;} Create a map 1234// m2 == empty mapm2 := make(map[string]int)// initialize the spacem2 := make(map[string]int, 5) Traversing the map (using range) 123for k, v := range m { fmt.Println(k, v)} Get Element Unlike Python when accessing non-exist key, it will pop exceptions, Go will not, and it will return two values on accessing the value through keys, 1) the value itself, and 2) a bool of whether the element exists 12345678// ok will be whether the key existscourseName, ok := m1[&quot;course&quot;]if courseName, ok := m1[&quot;course&quot;]; ok { fmt.Println(&quot;causeName&quot;)} else { fmt.Println(&quot;key does not exist&quot;)} Delete Element The delete() function is a direct and effective way to eliminate a key−value pair from a map. By specifying the key to delete, you can promptly remove the corresponding data from the map. 123// delete(mapName, key)name, ok := m[&quot;name&quot;]delete(m, &quot;name&quot;) Map's Key Map uses hashmap as its data structure, so other than slice, map, function, other type can be used as keys. Sturct data without slice, map and function can also be the key Functions in Go Typical Function 1234567891011121314// return voidfunc add(x int, y int) { fmt.Println(&quot;Hello, World!&quot;)}//-------arguments-----return------func add(x int, y int) int { return x + y}//-----same type arguments-----------func add(x, y int) int { return x + y} Multiple Returns 123456789func swap(x, y string) (string, string) { return y, x}//in mainfunc main() { a, b := swap(&quot;hello&quot;, &quot;world&quot;) fmt.Println(a, b) //prints &quot;world hello&quot;} Named Returns You can declare return variables and name them at the beginning, they are returned in the end. 12345678//Returns x,y at the end.func split(sum int) (x, y int) { x = sum * 4 / 9 y = sum - x // by default, it returns x and y return //return a,b &lt;- u can override default return of x,y.} Variadic Functions The rightmost argument can be a list of variable size (slice) of data. ... three dots means you are passing a variable size of data 123456789101112131415161718func average(x int, values ...int) float64 { //print values fmt.Println(&quot;Single argument value: &quot;, x) fmt.Println(&quot;Variable argument values: &quot;, values) //calculate average total := 0 for _, value := range values { total += value } return float64(total) / float64(len(values))}func main() { avg := average(10,20,30,40,50) println(&quot;Average:&quot;, avg)} Defer Keyword Defer used before a functions executes the function at the end of the scope of it. usually used to close opened files/buffers so you open the file and closes it using defer in the next line to keep things clean. they're executed as a stack. 123456fmt.Println(&quot;One&quot;)defer fmt.Println(&quot;Four&quot;)defer fmt.Println(&quot;Three&quot;)fmt.Println(&quot;Two&quot;)//Prints One Two Three Four Type Function and Returning Functions Functions can be assigned to variables func0 := func() int {x++; return x} Functions that are returned from another functions has its own scope per returned function 123456789101112131415161718192021package mainfunc incrementGlobalX() int { x++ return x}func wrapper() func() int { x := 0 return func() int { x++ return x }}func main() { fn := wrapper() fmt.Print(wrapper()) fmt.Print(wrapper()) // print 12} 123456789101112131415161718192021222324252627282930313233343536package mainvar x = 0func main() { //local x x := 0 func0 := func() int {x++; return x} func1 := incrementGlobalX //without () func2 := wrapper() func3 := wrapper() println(func0(), &quot; : func0 (local x)&quot;) println(func1(), &quot; : func1 (global x)&quot;) println(func2(), &quot; : func2 (per func scope x1)&quot;) println(func3(), &quot; : func3 (per func scope x2)&quot;) println(&quot;Second Increment&quot;) println(func0(), &quot; : func0 (local x)&quot;) println(func1(), &quot; : func1 (global x)&quot;) println(func2(), &quot; : func2 (per func scope x1)&quot;) println(func3(), &quot; : func3 (per func scope x2)&quot;)}func incrementGlobalX() int { x++ return x}func wrapper() func() int { x := 0 return func() int { x++ return x }} Receiver Receiver is the way you create a method for a specific type/struct 123456789101112type rect struct { width, height int}// (r *rect) is called rceiverfunc (r *rect) area() int { return r.width * r.height}r := rect{2,3}areaX := r.area()fmt.Println(areaX) Pointers Similar to C/C++ 123456789var value int = 1000var pointer *int = &amp;valueprintln(value) //1000println(pointer) //0xfffffffffprintln(*pointer) //1000(*pointer)++ //1001*pointer = *pointer + 10 //1011println(*pointer) //1011println(*pointer + *pointer) //1011 + 1011 = 2022 Difference? Pointer cannot do arithmetic calculation: you can change what pointer points to, but you cannot change the pointer itself Pass by value &amp; Pass by reference Every thing is passed by value except arrays, slices, maps and channels which some calls reference types, these types are passed by reference ( they internally have pointers, so no copying of the actual data happens when passing them) . Unlike C, where the address of a local variable will be recollected after the function returns, it's perfectly OK to return the address of a local variable (like Java); the storage associated with the variable survives after the function returns. Reference https://github.com/sherifabdlnaby/Golang-study-notes Coursera - Functions, Methods, and Interfaces in Go, University of California, Irvine. 慕课网 Google资深工程师深度讲解Go语言 由浅入深掌握Go语言","link":"/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Go/Go_fundamentals/"},{"title":"COMP3052 Computer Security 5 -- Firewall","text":"OSI Seven Layer Model (for reference) Firewall brief Firewall Basic Function Disadvantage of Firewall Types of Firewall Packet Filters Stateful (dynamic) Packet Filters Proxy Servers NAT (Network Address Translation) Why we need host-based firewall if we already have network-based firewall? IPTABLES (configures firewall in Linux) Example rules for IPTABLES Packet Filtering Policies (classification) Stateful Packet Filtering Policies [UNDERSTAND] NEW, ESTABLISHED, RELATED in IPTABLES Packet Filter Issues &amp; Drawbacks OSI Seven Layer Model (for reference) Firewall brief Usage: prevents unauthorised access of packets from one network to another. Functions: Implements 'single point' security measures Security event monitoring through packet analysis and logging Network-based access control through implementation of a rule set. Location: Network Firewalls: placed between a subnet and the internet Host-based Firewalls: placed on individual machines extended concept: DMZ (demilitarized zone) A demilitarized zone is a small subnet that separates externally facing services from the internal network Firewall is an implementation of DMZ Firewall Basic Function Firewall defends a protected network against parties services that should only be available internally (公司内网) Firewalls restrict access from inside to outside services Firewalls can perform Network Address Translation (NAT) Disadvantage of Firewall Cannot protect against attacks that bypass the firewall (tunneling) Cannot protect against internal threats or insiders Cannot protect against the transfer of virus-infected programs or files Types of Firewall Packet Filters Location: layer3 (network layer) and layer4 (transport layer) Goal: specify which packets are allowed or dropped, based on: Src / Dst IP TCP/UDP port number The packet filter will be used for both inbound and outbound traffic, and achieved by examining the packet header. Example implementation of Packet Fileter in Linux: IPTABLES Stateful (dynamic) Packet Filters Stateful packet filters understand requests and replies E.g. TCP open sequence (SYN, SYN-ACK, ACK) pattern Stateful packet filters can support policies for a wide range of protocols: TCP, FTP, IRC etc Proxy Servers Using a proxy server to represent you to send request to the server. So that it can prevent unwanted connection or malicious behaviours to the actual web server. Issues: large overhead (send packet to the proxy server first, and then the target web server) more expensive than packet filtering (need a seperate proxy server) Configuration is complex NAT (Network Address Translation) background: shortage of IP address Advantage: machine is totally hidden from the internet only established connections are forwarded to your internal machine prevent unsolicited attacks on random ports Why we need host-based firewall if we already have network-based firewall? Background: host-based firewall: firewall installed on endpoint devices: laptop, mobile devices, etc., Network-based firewall: A network-based firewall is a firewall software installed at the network perimeter, typically between an organization's internal network and the Internet. Why? Subnet is not secure. Attack may come from internal, not external IPTABLES (configures firewall in Linux) Brief: - First rule to match is applied - Rules are organized in chains - Uses tables to store chains, matches result in a jump, else we check next rule - Multiple chains can exist in one table Example rules for IPTABLES 1iptables -A INPUT -i eth0 -p tcp --dport 80 -j DROP where: Parameter Meaning -A Appending to specific chains INPUT Rule in INPUT chain -i Checking incoming service request eth0 Through network adapter 1 tcp Rule applies to TCP protocol instead of UDP --dport Destination port (the listening port on this machine) -j Jump DROP Jump target is DROP, which means to drop all incoming request Packet Filtering Policies (classification) Permissive (Black listing) - allow everything except dangerous service: easy to make mistakes 1234# allow all input/forward/outputiptables -P INPUT/FORWARD/OUTPUT ACCEPT# but restrict incoming connection to the machine ssh servicesiptables -A INPUT -p tcp --dport ssh -j DROP Restrictive (White listing) - block everything except designated useful services: secure, but easy to DoS yourself 1234# drop all input/forward/outputiptables -P INPUT/FORWARD/OUTPUT DROP# allow outgoing SSH traffic iptables -A OUTPUT -p tcp --dport ssh -j ACCEPT Stateful Packet Filtering Policies IPTABLES has modules for stateful packet filtering Allow incoming / outgoing SSH connections 12iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW, ESTABLISHED -j ACCEPTiptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state NEW, ESTABLISHED -j ACCEPT [UNDERSTAND] NEW, ESTABLISHED, RELATED in IPTABLES NEW — A packet requesting a new connection, such as an HTTP request. ESTABLISHED — A packet that is part of an existing connection. RELATED — A packet that is requesting a new connection but is part of an existing connection. Packet Filter Issues &amp; Drawbacks Cannot prevent attacks that exploit application-specific vulnerabilities Cannot support higher-level authentication schemes Easy to accidentally allow or deny packets incorrectly","link":"/wiki/Lecture%20Note/COMP3052%20Computer%20Security/CS7/"},{"title":"腾讯2024暑期实习笔试","text":"Q1 小红的图上染色 题目描述 输入描述 输出描述 示例1 解题思路 Q2 小红的链表破裂 题目描述 示例1 解题思路 Q3 小红的连通图 题目描述 输入描述 输出描述 解题思路 Q4 小红的数组分割 题目内容 输入描述 输出描述 示例1 解题思路： Q5 小红的tencent矩阵 题目描述 输入描述 输出描述 示例1 解题思路 Q1 小红的图上染色 题目描述 小红拿到了一个无向图，其中一些边被染成了红色，小红定义一个点为”好点“，当且仅当这个点的所有邻边都是红边。现在请你求出这个无向图”好点“的数量 注意：如果一个节点没有任何邻边，那么它也是好点 输入描述 第一行输入两个正整数\\(m\\),\\(n\\)，代表节点的数量和边的数量。 接下来的m行，每行输入两个正整数\\(u\\), \\(v\\)和一个字符chr，代表节点u和v有一条边连接，如果chr为'R'，代表这条边被染红；'W'代表未被染色 \\(1 &lt;= n, m &lt;= 10^5\\) \\(1 &lt;= u, v &lt;= n\\) 输出描述 一个整数，代表“好点”的数量 示例1 输入 123454 41 2 R2 3 W3 4 W1 4 R 输出 11 说明： 只有1号节点是好点 解题思路 无向图使用邻接表构建出邻接表，再构建一个node的hashmap储存红边数量，最后判断邻接表长度是否等于红边数量。 123456789101112131415161718192021222324# edge: [[&quot;1&quot;, &quot;2&quot;, &quot;R&quot;], [&quot;2&quot;, &quot;3&quot;, &quot;W&quot;], [&quot;3&quot;, &quot;4&quot;, &quot;W&quot;], [&quot;1&quot;, &quot;4&quot;, &quot;R&quot;]]def build_graph_and_red_edges(edges: List[List[str]]): # 用于储存图 graph = defaultdict(list) # 用于储存一个node的红边数量 red = defaultdict(int) for u, v, color in edges: graph[int(u)].append(v) graph[int(v)].append(u) if color == &quot;R&quot;: red[int(u)] += 1 red[int(v)] += 1 return graph, reddef count_good_nodes(graph, red, n): res = 0 for node in range(1, n+1): if len(graph[node]) == red[node]: res += 1 return res Q2 小红的链表破裂 题目描述 小红拿到了一个链表。她准备将这个链表断裂成两个链表，再拼接到一起，使得链表从头节点到尾部升序。你能帮小红判断是否达成目的吗？ 给定的为一个链表数组，你需要对于数组中每个链表进行一次“是”或“否”的回答，并返回布尔数组。 每个链表的长度不小于2，且每个链表中不包含两个相等的元素。所有链表的长度之和保证不超过\\(10^5\\) 示例1 输入： 1[{1, 2, 3}, {2, 3, 1}, {3, 2, 1}] 输出： 1[true, false, true] 说明： 第三个链表无论怎么操作都不满足条件 解题思路 只有三种情况： 升序 先升序后降序 先降序后升序 才能满足断裂后拼接在一起时满足升序的 123456789101112131415161718def check_sorted_linked_lists(arr): results = [] # 由于我不知道原题的输入长什么样 # 暂且按照数组来进行代码处理 for lst in arr: # 找到链表(数组)中的最大值和最小值的位置 min_index = lst.index(min(lst)) max_index = lst.index(max(lst)) # 判断三种情况 # 1. 升序 # 2. 先升序后降序 # 3. 先降序后升序 if sorted(lst[:min_index+1]) == lst[:min_index+1] and sorted(lst[max_index:]) == lst[max_index:]: results.append(True) else: results.append(False) return results Q3 小红的连通图 题目描述 小红拿到了一个有n个节点的无向图，这个图初始并不是连通图。 现在小红想知道，添加恰好一条边使得这个图连通，有多少种不同的加边方案？ 输入描述 第一行输入两个正整数\\(n\\), \\(m\\)，用空格隔开。 接下来的m行，每行输入两个正整数\\(u\\), \\(v\\)，代表节点u和节点v之间有一条边连接。 \\(1 &lt;= n, m &lt;= 10^5\\) \\(1 &lt;= u, v &lt;= n\\) 保证给出的图示不连通的。 输出描述 一个整数，代表加边的方案数 解题思路 我不会，让我想想... Q4 小红的数组分割 题目内容 小红拿到了一个数组，她准备将数组分成k段，使得每段内部按位异或之后，再全部求和，小红希望最终这个和尽可能大，你能帮帮她吗（不能） 输入描述 输入包含两行，第一行两个正整数\\(n\\), \\(k\\)，\\(1 &lt;= k &lt;= n &lt;= 400\\)，分别表示数组的长度和要分的段数。 第二行\\(n\\)个整数\\(a_i\\) (\\(0 &lt;= a_i &lt;= 10^9\\))，表示数组a的元素。 输出描述 输出一个正整数，表示最终的最大和 示例1 输入： 126 21 1 1 2 3 4 输出： 110 解释说明： 小红将数组分为了[1, 4], [5, 6]两个区间，得分分别为：\\(1 \\oplus 1 \\oplus 1 \\oplus 2 = 3\\) 和 \\(3 \\oplus 4 = 7\\)，总得分为10。可以证明不存在比10更优的分割方案。 解题思路： 采用动态规划的方法，用dp table记录当前位置将数组分成若干段的最大异或和，我们尝试所有可能的分段方法，更新dp table以找到最大的异或和。 利用异或运算的逆运算是其本身，可以使用异或前缀和的方法快速计算任何一段异或和 1234567891011121314151617181920212223242526272829from typing import Listdef max_xor(nums: List[int], k: int): # acquire the length of the array n = len(nums) # calculate pre-sum of xor pre_sum_xor = [0] * n pre_sum_xor[0] = nums[0] for i in range(1, n): pre_sum_xor[i] = pre_sum_xor[i-1] ^ nums[i] dp = [[0] * (k+1) for _ in range(n)] # dp[i][j] 表示index为i的元素分成j段的最大异或和 for i in range(n): for j in range(1, k+1): # 只有一段的时候，直接计算从头到当前位置的异或和 if j == 1: dp[i][j] = pre_sum_xor[i] # 多于一段的时候 # 最大值 = ”前段异或和 + 前面部分“ 与 ”当前“ 最大值 else: # 尝试不同的分段点 for m in range(j, i): dp[i][j] = max(dp[i][j], dp[m][j-1] + (pre_sum_xor[i] ^ pre_sum_xor[m])) return dp[n-1][k]; Q5 小红的tencent矩阵 题目描述 小红拿到了一个字符矩阵，她可以从任意一个地点除法，希望走6步之后恰好形成“tencent”字符串，小红想知道，共有多少种不同的行走方案？ 注意：每一步可以选择上，下，左，右任意一种方向行走，不可行走到矩阵外部。 输入描述 第一行输入两个正整数\\(n\\), \\(m\\)，代表矩阵的行数和列数。 接下来的n行，每行输入一个长度为m，仅由小写字母组成的字符串，代表小红拿到的矩阵。 输出描述 一个整数，代表最终合法的方案数 示例1 输入： 12343 3tennecten 输出： 14 说明： 从左上角出发，右右下左左上 从左上角出发，右右下左左下 从左下角出发，右右上左左下 从左下角出发，右右上左左上 解题思路 dfs + 剪枝，符合加1，不符合直接返回 1234567891011121314151617181920212223242526def count_matrix(matrix: List[List[str]]): n, m = len(matrix), len(matrix[0]) expect = [&quot;t&quot;, &quot;e&quot;, &quot;n&quot;, &quot;c&quot;, &quot;e&quot;, &quot;n&quot;, &quot;t&quot;] res = 0 def dfs(i: int, j: int, count: int): if i &lt; 0 or j &lt; 0 or i &gt;= n or j &gt;= m: return if count &gt;= len(expect) or matrix[i][j] != expect[count]: return if count == len(expect)-1: nonlocal res res += 1 dfs(i+1, j, count+1) dfs(i-1, j, count+1) dfs(i, j+1, count+1) dfs(i, j-1, count+1) for i in range(n): for j in range(m): dfs(i, j, 0) return res","link":"/wiki/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AF%95/tencent/"},{"title":"Git: How to do pre-commit","text":"STEP1: Find .git/hooks STEP2: Create pre-commit file STEP3: edit pre-commit file STEP1: Find .git/hooks Find the hooks folder in the (hidden) .git configuration folder 1cd .git/hooks STEP2: Create pre-commit file 1touch pre-commit STEP3: edit pre-commit file 1vi pre-commit and add something like this: 12345678910111213141516#!/bin/bash# store the top level git repository pathroot_directory=$(git rev-parse --show-toplevel)# list all subdirectoriessubdirectories=(&quot;HW1&quot;, &quot;HW2&quot;, &quot;HW3&quot;)# iterate over each subdirectoryfor subdir in &quot;$(subdirectories[@])&quot;;do (cd &quot;$root_directory/$subdir&quot; &amp;&amp; make clean)done# Continue with the commitexit 0 Now whenever you commit, it will automatically clean the subdirectory and will not commit any executable files. Note, if the operating system changes, the script will also need to change.","link":"/wiki/Git/git_tip1/"},{"title":"COMP3052 Computer Security 4 -- Access Control","text":"[IMPORTANT] Background Difference between authentication and access control: Access control has two steps - Authentication &amp; Authorisation Principal vs Subject vs Object Access Operations [IMPORTANT] Access Control Structures Intermediate Controls Groups Negative Permission Privileges Robe-based Access Control (RBAC) Protection Rings Comparing Security Attributes Partial Ordering Multi-Level Security Lattice Others [IMPORTANT] Background To discuss access control, we first have to develop a suitable terminology. The very nature of 'access' suggests that: There is an active entity - a subject or principal Accessing a passive object with some specific access operation While a reference monitor grants or denies access Fundamental Model of Access Control Difference between authentication and access control: Authentication verify identity Access control stipulates who can or cannot access certain resources Access control has two steps - Authentication &amp; Authorisation Authentication Decide who has access to the system Authorisation of those with access, who is authorised to do something to the resource (object) Principal vs Subject vs Object Principal: An entity that can be granted access to objetcs or can make statements affecting access control decisions user identity in an OS, used when discussing security policies Subject: An active entity within an IT system (active party) process running under a user identity, used when discussing operational system enforcing policies. Object: Files or resources (passive party) Access Operations Access Mode Observe: look at the contents of an object Alter: change the contents of an object General Model on common access on files: Read (concern: confidentiality) Write (concern: integrity) Execute Ownership (in charge of setting security policies) Owner can be defined for each resource, owner controls who gets access Or the security policy is a system-wide mandatory policy [IMPORTANT] Access Control Structures Access Control Matrix (ACM) At a basic level, access rights can be defined individually for each combination of subject and object simply and object simply in the form of a table. The access control matrix is an abstract concept and not very suitable for direct implementation if the number of subjects and objects is large or if the sets of subjects and object change frequently. Capabilities There are two fundamental options for implementing an access control matrix. Access rights can be kept with the subjects or with the objects. In the first case, every subject is given a capability, an unforgeable(不可伪造的) token that specifies this subject's access rights. This capability corresponds to the subject's row in the access control matrix Disadvantage It is difficult to get an overview of who has permission to access a given object It is difficult to revoke(撤销) a capability - either the operating system has to be given the task or users have to keep track of all the capabilities they have passed on Access Control Lists (ACL) Less memory used Stored with a file and quick to access but: management of individual subjects is cumbersome obtaining an overview of permissions is challenging tedious to set this up for every subjects and objects UNIX simplifies the ACL structure: User/Group/others Windows extends usual rwe with: take ownership change permission delete Intermediate Controls Problems of complexity are solved by indirection. This principle can be applied to access control. Intermediate layers between users and objects are introduced to represent policies in a more manageable fasion. Groups Users with similar access rights are collected in groups and groups are given permissions to access objects, and are thus a mean of simplifying the definition of access control policies. Negative Permission an entry in an access control structure that specifies the access operations a user is not allowed to perform. Policy Conflict In the above image, the negative permission given to u3 contradicting the positive permission given to group g1, and thus an example of policy conflict. Can be resolved by reference monitor e.g., a simple and widely used algorithm is just process the first entry matching in ACL(Access Control Lists) and ignore the later entries Privileges Privileges A policy could refer to the operationss a user is allowed to execute. Privilege stands for the right to execute certain operations Usually associating with operating system functions Robe-based Access Control (RBAC) Compared with ACL: Identity-based Access Control (IBAC) Access is based on a role, e.g. accountants should access certain financial files role -&gt; collection of application specific operations or resource access Difference with group and role: group are collections of users roles are collections of permissions RBAC focuses on users and the jobs they perform Easier to scale and applicable to large networks and organizations (enterprise level) Most operating systems are user/group based, so role-based access can be provided using nested groups Protection Rings protection rings Protection rings are a particularly simple example of an intermediate layer of hardware-based access control for subjects and objects. Each subject (process) and each object is assigned a number, depending on its 'importance'. Access control decisions are made by comparing the subject's and object's numbers Comparing Security Attributes When evaluating a security policy, he reference monitor compares the access rights granted to the subject with the access rights demanded by the policy. Partial Ordering A security policy might grant access to an object if the object label is \\(\\le\\) subject label Considering the above example, the department creates a group Year_1 for first year students to manage access for resources specifically dedicated to them. There is also a group Year_2 for second year students, Year_3 for third year students, etc. The group of first year students would be contained in the group of all students, but there is no such relation between group Year_1 and Year_2. By using Hasse diagrams (a graphical representation of partially ordered sets in the above image), the edges in the diagram give a seleton of the partial ordering, which is \\(a \\le b\\) if and only if there a path from a to be. In this case, \\(\\{Year\\_1\\} \\le \\{Year\\_1, Year\\_2\\}\\), and a security policy might grant access to an object if the object label is \\(\\le\\) subject label. Multi-Level Security multi-level security Linearly ordered hierarchy of four security levels in early security research in 1970s and 1980s: often in military applications. Lattice The linear ordering of security levels in Multi-Layer security can only express a limited security policies, while in order to be able to state other policies, such as people at level secret could have access to lower categories, a lattice of security levels was introduced. Lattice Others JVM: sandboxing - run code in restricted environments Virtualization - emulates a number of other machines Trusted computing - verifiable state of software and hardware","link":"/wiki/Lecture%20Note/COMP3052%20Computer%20Security/CS6/"},{"title":"Tips when defining global constant in header file","text":"Options of defining global constant in header file #define GLOBAL_CONST_VAR 0xFF const int GLOBAL_CONST_VAR = 0xFF; extern const int GLOBAL_CONST_VAR; and in one source file uses cosnt int GLOBAL_CONST_VAR = 0xFF; According to Effective C++, ITEM 2: Prefer const, enum, and inline to #define. So option 1 is not preferred (which I particularly like to use). In my project, I have a header file that uses three constant string. 1234// util.hppconst char * CLIENT_CONNECT_CONFIRM = &quot;CLIENT_CONFIRM&quot;;const char * SERVER_CONNECT_CONFIRM = &quot;SERVER_CONFIRM&quot;;const char * PLAYER_CONNECT_CONFIRM = &quot;PLAYER_CONFIRM&quot;; However, when I run the makefile, it has the error goes like: 1/usr/bin/ld: player.o:/home/fg96/ECE650/HW3/util.hpp:14: multiple definition of `CLIENT_CONNECT_CONFIRM'; util.o:/home/fg96/ECE650/HW3/util.hpp:14: first defined here Which clearly indicates that the CLIENT_CONNECT_CONFIRM are regarded not as the constant, but variable, but why? Reason is that const char * ... is not constant, because const char * means that the value pointer points to cannot change, but the value of the pointer can change (very silly mistake). The following definition will be just fine: 123456789// all const pointers pointing to const valuesconst char * const CLIENT_CONNECT_CONFIRM = &quot;CLIENT_CONFIRM&quot;;const char * const SERVER_CONNECT_CONFIRM = &quot;SERVER_CONFIRM&quot;;const char * const PLAYER_CONNECT_CONFIRM = &quot;PLAYER_CONFIRM&quot;;// const pointers is also finechar * const CLIENT_CONNECT_CONFIRM = &quot;CLIENT_CONFIRM&quot;;char * const SERVER_CONNECT_CONFIRM = &quot;SERVER_CONFIRM&quot;;char * const PLAYER_CONNECT_CONFIRM = &quot;PLAYER_CONFIRM&quot;; Since C++17, inline specifier can also be used on variable. According to the cppreference: An inline function or variable(since C++17) with external linkage (e.g. not declared static) has the following additional properties: There may be more than one definition of an inline function or variable(since C++17) in the program as long as each definition appears in a different translation unit and (for non-static inline functions and variables(since C++17)) all definitions are identical. For example, an inline function or an inline variable(since C++17) may be defined in a header file that is included in multiple source files. But we are not allowed to use c++17 so ... Another possibility would be to use namespace 123namespace { char * CLIENT_CONNECT_CONFIRM = &quot;CLIENT_CINFIRM&quot;;} Reference Defining global constant in C++ 头文件中定义const全局变量应注意的问题","link":"/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/const/"},{"title":"About master theorem","text":"Background In ECE590, a horrible professor talked so little about the master theorem. I was so confused about it. Two months later, one of my friends at USC reminded me of this and I certainly cannot understand by this point. In this blog, some points will be clarified which I do not want to repeat this over and over again in the future. Recurrence equation In the merge sort algorithm, the recurrence equation is given by: \\(T(n) = T(\\lceil n / 2 \\rceil) + T(\\lfloor n / 2 \\rfloor) + O(n)\\) This should be the correct version, however, we can safely strip out the floors and ceilings (using a technique called domain transformations), giving us a simpler recurrence: \\(T(n) = 2T(n/2) + O(n)\\) More formally, the recurrence of the form: \\(T(n) = aT(n/b) + f(n)\\) characterizes a divide-and-conquer algorithm that creates \\(a\\) subproblems, each of which is \\(1/b\\) the size of the original problem, and in which the divide and combine steps together take f(n) time. So: \\(a\\): number of subproblems \\(b\\): size of subproblems in regards to the original problem \\(f(n)\\): divide and conquer steps together take f(n) time divide-and-conquer Define Master Theorem Let \\(a \\ge 1\\) and \\(b &gt; 1\\) be constants, let \\(f(n)\\) be a function, and let \\(T(n)\\) be defined on the nonnegative integers by the recurrence: \\(T(n) = aT(n/b) + f(n)\\) where we interpret n/b to mean either \\(\\lfloor n/b \\rfloor\\) or \\(\\lceil n/b \\rceil\\). Then \\(T(n)\\) can be bounded asymptotically as follows: If \\(f(n) = O(n^{\\log_ba - \\epsilon})\\) for some constant \\(\\epsilon &gt; 0\\), then \\(T(n) = O(n^{\\log_ba - \\epsilon})\\). If \\(f(n) = \\Theta(n^{\\log_ba})\\), then \\(T(n) = \\Theta(n^{\\log_ba})\\logn\\). If \\(f(n) = \\Omega(n^{\\log_ba + \\epsilon})\\) for some constant \\(\\epsilon &gt; 0\\), and if \\(af(n/b) \\le cf(n)\\) for some constant \\(c &lt; 1\\), and all sufficiently large \\(n\\), then \\(T(n) = \\Omega(f(n))\\) Here, there are one thing that is universal across the three cases, the is in each of the three cases, function \\(f(n)\\) is compared with the function \\(n^{\\log_ba}\\). Why \\(n^{\\log_ba}\\)? Or if the form changes to (which is taught at ECE590): if \\(T(n) = aT(n/b) + O(n^d)\\) (for constants \\(a &gt; 0, b &gt; 1, d \\ge 0\\) independent of n) then: \\[ T(n) = \\left\\{\\begin{aligned}&amp; O(n^d) &amp; d &gt; \\log_ba \\\\ &amp; O(n^d \\log_{}n) &amp; d = \\log_ba \\\\ &amp; O(n^{\\log_ba}) &amp; d &lt; \\log_ba\\end{aligned}\\right.\\] An answer on Reddit here told me an intuitive way of understanding this, here the \\(\\log_ba\\) is also called critical exponent: The intuition behind master theorem is that you imagine taking a specific input to the algorithm, then you visualize all the recursive calls it will make as one huge tree, and then you compute the total running time of the algorithm by taking each level of the recursion tree separately and summing up the work done while on that level. As you go down the recursion tree, the number of subproblems increases exponentially while at the same time the size of each subproblem and therefore also the work done in each subproblem decreases exponentially. Then there will be two classifications: If the number of subproblems (\\(a\\)) grows faster, almost all work is done in the leaves, i.e., when solving the final calls that are handled in constant time. If the amount of work (\\(b\\)) decreases faster, you get the exact opposite: almost all work is done in the root of the tree (i.e., outside of all recursive calls) and the rest is negligible. The critical exponent is exactly between those two: the subproblem count increases at the same rate at which the amount of work decreases. Then you get the same total amount of work on each level of the recursion tree, which means that your total time complexity is (the work done on any single level) times (the number of levels). But why \\(\\log_ba\\) and what is \\(d\\)? This is because we have not give a general solution to the general form of the recurrence function: \\(T(n) = aT(n/b) + f(n)\\). The solution for this is: \\(T(n) = \\displaystyle \\sum^{\\log_bn}_{i=0} a^if(n.b^i) + O(n^{\\log_ba})\\) This can be seen by drawing the tree generated by the recurrence. The tree has depth \\(\\log_bn\\). There are \\(a^i\\) nodes at level \\(i\\), each labeled \\(f(n/b^i)\\). The value of \\(T(n)\\) is the sum of the labels of all the nodes of the tree. divide and conquer general solution recurrence tree The last term \\(O(\\log_ba)\\) is the sum across the leaves, which is \\(a^{\\log_bn} \\cdot f(1) = n^{\\log_ba} \\cdot f(1)\\) why \\(a^{\\log_bn} = n^{\\log_ba}\\)? \\[ \\begin{aligned} a^{\\log_bn} &amp;= (b^{\\log_ba})^{\\log_bn}\\\\ &amp;= b^{\\log_ba \\cdot \\log_bn}\\\\ &amp;= b^{\\log_bn \\cdot \\log_ba}\\\\ &amp;= (b^{\\log_bn})^{\\log_ba}\\\\ &amp;= n^{\\log_ba} \\end{aligned} \\] So now, if we intuitively think about this theorem again: if \\(d &gt; \\log_ba\\), then it means most of the job are done at the root level (considering the O(f(n)) is larger that leaves, which is \\(O(n^{\\log_ba}\\))). if \\(d = \\log_ba\\), then it means it is the same as the general solution and thus the time complexity is \\(O(n^d\\log_{}n) = O(n^{\\log_ba} \\log_{}n) = O(a^{\\log_bn} \\log_{}n)\\) which means the height times the bottom leaves. if \\(d &lt; \\log_ba\\), then most of the job are done at the leaves. References Reddit - intuition_behind_critical_exponent_in_masters master method proof - cornell Algorithms - JeffE","link":"/wiki/Algorithm/master_theorem/"},{"title":"Multi Domain With Different Reverse Proxy","text":"Multi Domain With Different Reverse Proxy Scenario My original setup Multi Domain With Different Reverse Proxy Scenario If you have one domain name, that is fine. However, if you have multiple domain with multiple website, but you only have one physical machine (also means you only have one public ip address). The way to deal with this is to do a little bit setup in nginx.conf My original setup I have a machine that hosts my blog (which is this one) at https://www.tragicmaster.website. So my original setting (also can see in my SSL build blog here. 1234567891011121314151617181920212223# Default server configurationserver { listen 80 default_server; listen [::]:80 default_server; # SSL configuration listen 443 ssl default_server; listen [::]:443 ssl default_server; ssl_certificate cert/tragicmaster.website.crt; ssl_certificate_key cert/tragicmaster.website.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; server_name tragicmaster.website; location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; }} And now I have a container running on localhost:8000, which is my second website that I want other people to access. I tried several ways while this works for me: I create another setting so that when nginx see the domain name that I use is 'https://www.duber.site', it will redirect to the localhost:8000. 1234567891011121314151617181920212223242526server { listen 80; listen [::]:80; server_name www.duber.site; location / { proxy_pass http://localhost:8000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } # Add any additional SSL configurations if needed listen 443 ssl; listen [::]:443 ssl; ssl_certificate cert/duber.site.crt; ssl_certificate_key cert/duber.site.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; # Add any other server configurations as needed} This is way how one ip, multi domain and multi application running together.","link":"/wiki/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/MultiDomain/"},{"title":"C# 基础 - 面向对象","text":"面向对象（object-oriented programming) 构造方法（constructor）和方法重载（Method Overloading） C#严格界定字段（Fields）、属性（Properties） 属性定义的基本模式 表达式主体定义 7.2.3 自动实现属性 const，readonly和writeonly 对象索引（普通索引[点击此处](#SDDo8)） 索引重载 Partial类 分开两个文件 使用范围 注意事项 松耦合设计思想 耦合 Coupling 低耦合/松耦合 UML类关系 - 依赖、关联、聚合、组合、泛化 依赖（Dependency） 关联（Association） 聚合（Aggregation） 组合/复合 Composition 聚合（Aggregation）v.s. 组合（Composition） 泛化 (Generalization) 继承 复合 访问修饰符（protected与internal） protected internal 构造函数的继承 base关键词 向上转型和向下转型 向上转型（upcasting） 7.12.2 向下转型（downcasting） as keyword is keyword 面向对象（object-oriented programming) class高内聚、低耦和：功能相关事物应该放在同一个集合中形成一个模块，这就叫做高内聚，而这些模块又应该是相互独立的，不同的模块之间应该保持一个低耦合的状态。 构造方法（constructor）和方法重载（Method Overloading） 1234访问修饰符 class名() { 代码逻辑，用于初始化数据等} 12345public Point(int x, int y){ this.x = x; this.y = y;} 1234567891011public Point(){ x = 15; y = 5;}public Point(int x, int y){ this.x = x; this.y = y;} C#严格界定字段（Fields）、属性（Properties） 在Java里，一般对于Private我会用Idea自带的重构自己生成getter函数和setter函数，这些函数属于成员函数，在C#里这些被定义为属性（Properties）属性：https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/properties 属性定义的基本模式 1234567891011121314151617public class TimePeriod{ private double _seconds; public double Hours { get { return _seconds / 3600; } set { if (value &lt; 0 || value &gt; 24) throw new ArgumentOutOfRangeException(nameof(value), &quot;The valid range is between 0 and 24.&quot;); _seconds = value * 3600; } }} value关键字用于定义由 set 或 init 访问器分配的值，TimePeriod类表示时间间隔。 在内部，该类将时间间隔以秒为单位存储在名为 _seconds 的私有字段中。 名为 Hours的读-写属性允许客户以小时为单位指定时间间隔。get 和 set访问器都会执行小时与秒之间的必要转换。 此外，set访问器还会验证数据，如果小时数无效，则引发ArgumentOutOfRangeException在C#中，定义字段会使用小写，private的话加一个下划线（如上面的_seconds），属性会使用大写（如上面的Hours） 表达式主体定义 属性访问器通常由单行语句组成，这些语句只分配或只返回表达式的结果。 可以将这些属性作为 expression-bodied 成员来实现。 =&gt; 符号后跟用于为属性赋值或从属性中检索值的表达式，即组成了表达式主体定义。 1234567891011121314151617181920212223public class SaleItem{ string _name; decimal _cost; public SaleItem(string name, decimal cost) { _name = name; _cost = cost; } public string Name { get =&gt; _name; set =&gt; _name = value; } public decimal Price { get =&gt; _cost; set =&gt; _cost = value; }} 7.2.3 自动实现属性 通过使用自动实现的属性，既能简化代码，还能让 C# 编译器透明地提供支持字段 123456789public class SaleItem{ // 在这里编译器会自动创建一个private变量_name public string Name { get; set; } public decimal Price { get; set; }} const，readonly和writeonly 从getter、setter的角度来说来说，readonly就是只有getter的属性，而writeonly就是只有setter的属性 1234567// readonly// 初始化可以在构造器，也可以在下面的属性public int T { get; } = 5;// writeonlyprivate int _s;public int S { set {_s = value;} } 对于变量和字段，c#还提供了两个更加底层，更加接近编译级别的语法结构，就是使用 const 或者 readonly这两个声明修饰符。 123public const int a = 99;public readonly int b; 其中：const是常量，readonly是变量。也就是说const必须在声明同时赋值，而readonly可以在声明暂时不赋值，当class初始化的时候再进行赋值。const是在代码编译前就能定下来，所以他性能比readonly要高出不少。 对象索引（普通索引点击此处） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Point{ // 成员变量x轴，使用属性 private int _x; public void SetX(int value); ... public void GetX() =&gt; this.x; // 成员变量y轴 private int y; public void SetY(int value); ... public void GetY() =&gt; this.y; // 成员变量z轴 public int Z { get; set; } // 时间维度 public int T { get; } // 第五维度 private int _s; public int S { set { _s = value; } } // 第六维度 const int a = 99; // 第七维度 public readonly int b; // 加入第八维度数据 // 第八维，字符串数组 private string[] gamma = new string[] { // index from start index from end &quot;The&quot;, // 0 ^9 &quot;quick&quot;, // 1 ^8 &quot;brown&quot;, // 2 ^7 &quot;fox&quot;, // 3 ^6 &quot;jumped&quot;, // 4 ^5 &quot;over&quot;, // 5 ^4 &quot;the&quot;, // 6 ^3 &quot;lazy&quot;, // 7 ^2 &quot;dog&quot; // 8 ^1 }; // 9 (or words.Length) ^0 // 对于这些数据，我们可以通过给他们建立class级别的索引进行快速访问。 // 建立类级别的索引需要使用关键词this，加上他的index信息， // index信息为整数，当然也可以是string等其他类型 // 因为接下来我们需要从外部访问，所以声明为public； // 而每个索引所对应的数据是字符串类型，所以索引返回类型为string。 public string this[int index] { get { return gamma[index]; } set { gamma[index] = value; } } public Point() { this._x = 15; y = 10; T = 5; a = 15; b = 1000; }} 此时进行索引 1234// 获取point数组第一个，只是此时是成员变量Console.WriteLine(point[0]);// 修改point数组第一个point[0] = &quot;hello&quot;; 类索引Index的语法结构注意点： 创建索引需要使用this关键词 索引可以用于快速访问一组数据的某一项 索引的使用需要通过方括号 索引不能使用static、ref和out来修饰 索引重载 1234567public int this[string name]{ get { return Array.IndexOf(_g, name); }} Partial类 C#中有一个别致的功能叫做partial，它可以用来定义局部类或者局部方法。通过局部类型可以实现将一个类、结构、接口甚至是方法分成几个独立的代码片段，或者放在几个不同的.cs文件中，编译器在编译的时候，会找出这些独立的片段，并在编译的最后合并。partial类能让类变得更容易管理，有效降低我们单个文件的代码复杂性，让代码更容易被维护参考上面代码，这个class目前有九个成员变量，再加会显得非常的繁琐，使用partial可以解决这个问题 123456789public partial class Point{ public int D { get; set; } public void printDelta() { Console.WriteLine(&quot;我是第九维&quot;); }} 这样在main方法中访问point的printDelta这个方法了（这么神奇？） 12point.D = 1;point.printDelta(); 分开两个文件 局部类的好处就是能把一个类卸载两个独立的文件中，这样更加翻盖你我们对代码的管理命名时，还是以class的类名称开头，但是我们会给文件中加一个中间名称，方便与主文件区分，Point.Delta.cs 使用范围 类型特别大，不适合放在一个文件中实现 一个类型中的一部分代码为自动化工具生成的代码，不宜与我们自己编写的代码混合在一起 一个类需要多个人同时编写的时候 注意事项 只适用于类、接口、结构，不支持委托和枚举（partial只有和class、struct、interface放在一起时才表示局部类型） 同一个类型的各个部分必须有修饰符partial 使用局部类型时，一个类型的各个部分必须位于相同的命名空间中 一个类型的各个部分必须同时被编译 一个类型的各部分的访问修饰符必须保证一致性 局部类型具有累加效应 松耦合设计思想 耦合 Coupling 随着系统的复杂性增加，修改最底层的class A会引发系统级别的代码调整，这种代码的处理方式就叫做高耦合。所有的class都紧密的结合在一个类，牵一发则动全身 低耦合/松耦合 类之间存在关系，但是独立存在，两者之间为引用关系。 UML类关系 - 依赖、关联、聚合、组合、泛化 依赖（Dependency） 依赖关系用虚线加箭头表示，类A要完成某项功能引用了类B，则类A依赖类B。依赖在代码中主要体现为类A的某个成员函数的返回值，形参，局部变量或静态方法调用 123456789101112131415161718192021public class Computer { public static void start(){ Console.WirteLine(&quot;电脑正在启动&quot;); } };public class Student { //返回值构成依赖 public Computer program(); //形参构成依赖 public void program(Computer computer); public void playGame() { //局部变量构成依赖 Computer computer = new Computer(); ... //静态方法调用构成依赖 Computer.star(); }}; 关联（Association） 关联关系使用实线加箭头表示，类之间的关系比依赖要强。学生与老师是关联的，学生可以不用电脑，但是学生不能没有老师。如下图所示：发生关联关系的两个类，类A成为类B的属性，而属性是一种更为紧密的耦合，更为长久的持有关系。 在代码中的表现如下： 12345678public class Teacher { ...};public class Student { public Teacher teacher; //成员变量 public void study();}; 与依赖的区别： 发生依赖关系的两个类都不会增加属性。其中的一个类作为另一个类的方法的参数或者返回值，或者是某个方法的变量而已。 从关系的生命周期来看，依赖关系是仅当类的方法被调用时而产生，伴随着方法的结束而结束。关联关系当类实例化的时候产生，当类对象销毁的时候关系结束。相比依赖，关联关系的生存期更长 聚合（Aggregation） 聚合关系使用实线加空心菱形，用来表示集体与个体之间的关联关系。例如班级与学生之间存在聚合关系，类图表示如下：聚合关系在代码上与关联关系表现一致。 12345678910public class Student { ...};public class Class { private Student _student; //成员变量 public Class(Student student) { _student = student }}; ### 组合/复合 Composition 复合关系使用实线加实心菱形表示。用来表示个体与组成部分之间的关联关系。例如学生与心脏之间存在复合关系，类图表示如下：组合关系在代码上与关联关系表现一致。 12345678910public class Heart { ...};public class Student { private StudeHeartnt _heart; //成员变量 public Student() { _heart = new Heart（）; }}; ### 聚合（Aggregation）v.s. 组合（Composition） 聚合关系没有组合紧密。学生不会因为班级的解散而无法存在，聚合关系的类具有不同的生命周期；而学生如果没有心脏将无法存活，组合关系的类具有相同的生命周期。 &gt; 这个从构造函数可以看出。聚合类的构造函数中包含另一个类的实例作为参数，因为构造函数中传递另一个类的实例，因此学生可以脱离班级体独立存在。组合类的构造函数包含另一个类的实例化。因为在构造函数中进行实例化，因此两者紧密耦合在一起，同生同灭，学生不能脱离心脏而存在。 信息的封装性不同 在聚合关系中，客户端可以同时了解Classes类和Student类，因为他们是独立的。 在组合关系中，客户端只认识Student类，不知道Heart类的存在，因为心脏类被严密地封装在学生类中 理解聚合与复合的区别，主要在于聚合的成员可独立，复合的成员必须依赖于整体才有意义。 泛化 (Generalization) 泛化指的是类与类之间的继承关系和类与接口之间的实现关系。 继承 is-a关系C#中继承关系使用: 123456789public class Text: PresentationObject{ public int FontSize { get; set; } public string FontName { get; set; } public void AddHyperLink() { Console.WriteLine(&quot;添加超链接&quot;); }} 复合 has-a关系 1234567public class Logger{ public void Log(string message) { Console.WriteLine($&quot;日志 {DateTime.Now}: {message}&quot;); }} 1234567891011121314public class DbMigrator{ private readonly Logger _logger; public DbMigrator(Logger logger) { _logger = logger; } public void Migrate() { _logger.Log(&quot;数据迁移开始&quot;); // TODO: 处理数据迁移 }} 1234567891011121314public class Install{ private readonly Logger logger; public Install(Logger logger) { this.logger = logger; } public void install() { _logger.Log(&quot;安装开始&quot;); // TODO: 安装过程省略 }} 最后在main函数里面调用 1234567var logger = new Logger();var dbMigrater = new DbMigrator(logger);var installer = new Installer(logger);dbMigrater.Migrate(); ## 访问修饰符（protected与internal） protected 只要是被protected声明的变量或者方法，只能被自己访问、或者被继承于自己的子类访问，其他一切外部操作都无法访问。那么接下来，我们用代码尝试一下吧。 123456789101112131415161718192021public class Car{ public void Accelerate() { Console.WriteLine(&quot;加油&quot;); } protected void Stop() { Console.WriteLine(&quot;制动&quot;); }}public class WulinHongguang : Car{ public void Drift() { this.Accelerate(); this.Stop(); }} 如果Stop时private的话就无法访问了 internal 使用了 internal 修饰符以后，相关的代码只能在同一个程序集或者说同一个项目中使用，任何一个外部项目都没办法从外部对它进行访问。 构造函数的继承 12345678910111213141516public class Staff{ public Staff() { Console.WriteLine(&quot;员工类初始化&quot;); }}public class Manager : Staff{ public Manager() { Console.WriteLine(&quot;经理类初始化&quot;); }} 命令行中，我们得到了两行输出，“xxx”。输出结果表明，当我们在创建manager对象的时候，作为派生类，他不仅了调用自己的构建方法，甚至还会在调用自己之前先调用基类、也就是staff类的构造方法。 base关键词 12345678910111213141516171819202122232425262728public class Staff{ public Staff() { Console.WriteLine(&quot;员工类初始化&quot;); } public int Number { get; set; } public Staff(int number) { Number = number; }}public class Manager : Staff{ public Manager() { Console.WriteLine(&quot;经理类初始化&quot;); } public Manager(int number) { Console.WriteLine(&quot;{number}经理初始化&quot;); }} 运行一下发现，manger对象的编号为0，一般来说，整数对象如果没有赋值的时候就是0。所以，这就说明构造方法根本没有对员工编号赋值。这就说明，虽然我们在初始化manager对象的时候使用了参数，但是在调用继承构造方法的时候，并不是按我们预想的那样调用staff类有参数的构造方法，而是调用了无参数的默认构造方法。实际上，如果一个class存在多个构造方法，那么他在处理类继承的时候就面临着多个构造方法选择的问题。在默认情况下，无论基类有多少个构造方法，他的衍生类在创建对象的时候都会默认使用默认无参数构造方法执行继承工作。所以，这就是为什么manager对象的赋值会失败。 12345678910111213public class Manager : Staff{ public Manager() { Console.WriteLine(&quot;经理类初始化&quot;); } // 加个base(number)就能指定屌用继承构造函数 public Manager(int number) : base(number) { Console.WriteLine(&quot;{number}经理初始化&quot;); }} 向上转型和向下转型 向上转型（upcasting） 12345678910111213public class Shape{ // comment}public class Circle : Shape { // comment}Circle circle = new Circle();// implicit transform (upcasting)Shape shape = circle; 7.12.2 向下转型（downcasting） 1234567891011121314public class Shape{ // comment}public class Circle : Shape { // comment}Circle circle = new Circle();Shape shape = circle;// explicit transform (downcasting)Circle circle2 = (Circle)shape as keyword 为了防止这种低级错误，我们可以使用as关键词。比如说，有随便一个对象，我们希望把他转化为Car。显式转化如代码所示，我们连obj原始类型都不清楚，所以这段代码大概率会报错。 12345Car car = (Car) obj; // 可能会抛异常Car car = obj as Car; // 不会抛出异常if (car != null) { // continue} is keyword 使用is关键词，我们可以检查对象的类型。通过先进行类型验证，再执行对象转换，这样可以极大的提高我们代码的安全程度。 123if (obj is Car) { Car car = (Car) obj; // 不会出错} 如示例代码，如果obj is 是一辆 car，那么，我们就可以在if语句中安全的对obj进行汽车类型的转换了。否则，我们就不会obj做任何处理。","link":"/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/CSharp/CSharpOOP/"},{"title":"C# 基础 - 语法","text":"Using system &amp; Console &amp; hello world Console工具类中常见方法 列表，index索引，范围 逻辑判断（基本与Java一致，不赘述） if - else switch ？:操作符 循环（基本与Java一致，不赘述） for循环 while循环 do while循环 方法（Method） 方法定义（与Java有几处略有不同，不同之处红色字体标出） 访问修饰符（Access Specifier） 声明修饰符 (modifier) 方法表达式 值传参与引用传参 按引用传递参数 按输出传递参数 Using system &amp; Console &amp; hello world system是c#程序最基本的模块，这个模块可以提供各种各样已经提前定义好的功能 1234567891011121314using System;// namespace是当别人引用我们的代码的时候// 可以使用 using HelloWorldnamespace HelloWorld{ class Program { static void Main(string[] args) { Console.WriteLine(&quot;Hello World!&quot;); } }} Console工具类中常见方法 Write(): 括号内参数显示在命令行中 WriteLine(): 括号内参数显示在命令行中，显示完成后换行 Read(): 只读取第一次按下键盘的按钮（包含字符，ascii代码等本身所有信息） ReadKey(): 只读取第一次按下键盘的按钮（ascii代码） ReadLine(): 读取用户输入，直到按下回车 Clear(): 命令行所有内容清除 列表，index索引，范围 1234567891011121314151617181920212223string[] words = new string[]{ // index from start index from end &quot;The&quot;, // 0 ^9 &quot;quick&quot;, // 1 ^8 &quot;brown&quot;, // 2 ^7 &quot;fox&quot;, // 3 ^6 &quot;jumped&quot;, // 4 ^5 &quot;over&quot;, // 5 ^4 &quot;the&quot;, // 6 ^3 &quot;lazy&quot;, // 7 ^2 &quot;dog&quot; // 8 ^1}; // 9 (or words.Length) ^0// 第二个元素Console.WriteLine(words[1]);// 倒数第一个元素Console.WriteLine(words[words.Length-1]);// 倒数第一个元素(2)Console.WriteLine(words[^1]);// 范围索引，左闭右开var list = words[0..3]; 其中C#有两个类型专门用来储存index索引与范围：Index和Range 在C# 7出现Span它可以表示另一个数据结构里连续相邻的一串数据，并且它是内存安全的。C# 8 里面出现Range和Index, 还可以组合使用Range和Index 1234567891011121314151617181920string[] words = new string[]{ // index from start index from end &quot;The&quot;, // 0 ^9 &quot;quick&quot;, // 1 ^8 &quot;brown&quot;, // 2 ^7 &quot;fox&quot;, // 3 ^6 &quot;jumped&quot;, // 4 ^5 &quot;over&quot;, // 5 ^4 &quot;the&quot;, // 6 ^3 &quot;lazy&quot;, // 7 ^2 &quot;dog&quot; // 8 ^1};Range range = 1..4;Index index = ^1;Range complexRange = 1..^1;var newList1 = words[range];var newList2 = words[index];var newList3 = words[complexRange]; 逻辑判断（基本与Java一致，不赘述） if - else 123456// 基本与java一致if（weather == good）{ goSwimming();} else { notGoSwimming();} switch 12345678910111213switch(expression){ case constant-expression : statement(s); break; case constant-expression : statement(s); break; /* 可以有任意数量的 case 语句 */ default : /* 可选的 */ statement(s); break;} ？:操作符 1condition ? consequent : alternative 循环（基本与Java一致，不赘述） for循环 123for (int counter = 0; counter &lt; 10; counter = counter + 1) { Console.WriteLine(&quot;counter: &quot; + counter);} while循环 1234int couter = 0while（conter&lt;5）{ counter = counter + 1;} do while循环 1234int couter = 0do { counter++; } while(counter &lt; 5) 方法（Method） 方法定义（与Java有几处略有不同，不同之处红色字体标出） 123456789// Access Specifier: 访问修饰符// Modifier: 声明修饰符// Return Type: 返回类型// Method Name: 方法名// Parameter List: 参数列表// Method Body: 方法主体&lt;Access Specifier&gt; &lt;Modifier&gt; &lt;Return Type&gt; &lt;Method Name&gt; (Parameter List){ Method Body} 访问修饰符（Access Specifier） 定义了方法的访问属性，我们可以选择这个列表中的任意一个来描述方法的可见性public: 公有方法，可以被外部调用private: 私有，方法会被隐藏起来，其他class是不能调用的Protected: 只能在它的类本身或者它的派生类中访问Internal: 内部方法，同一个程序集（同名.cs文件）中的所有类都可以访问 声明修饰符 (modifier) C#中共有8个声明修饰符： 静态类型（static） 抽象类型（abstract） 派生类重写的虚函数（virtual） 允许方法继承后重写的override（与Java写的位置不同） 隐藏基类成员继承的new 表示不能被继承的sealed 允许在同一个程序集分散定义的partial 用于声明外部实现的Extern 方法表达式 除了普通的、使用花括号的方法定义方式，他还给我们提供了一个更加简单的语法结构，这种语法结构就是箭头表达式方法的签名保持不变，变化的是方法的主题部分 1public static int FindMax (int num1, int num2) =&gt; num1 &gt; num2 ? Num1 : num2 值传参与引用传参 值传参不必多说 12345678// x 和 y 不会交换 =&gt; 值传参public void swap(int x, int y){ int temp; temp = x; /* 保存 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 temp 赋值给 y */} 按引用传递参数 swap方法的两个参数前面加上关键词ref，实现引用传参 12345678// x 和 y 会交换 =&gt; 引用传参传参public void swap(ref int x, ref int y){ int temp; temp = x; /* 保存 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 temp 赋值给 y */} 按输出传递参数 1234567public void getValue(out int x){ int temp = 5; x = temp;}getValue(a); 这时候如果我们在调用getValue方法的同时，也加上out关键词，那么这个时候方法中x的数据就会突破限制，直接向参数a输出","link":"/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/CSharp/CSharpGrammar/"},{"title":"COMP3052 Computer Security 3 -- Authentication","text":"Lecture 4 Authentication Username &amp; Password Password [UNDERSTAND] Password Policies Storing passwords Cracking Passwords [UNDERSTAND] Password Salting (improve security) Multi-Factor Authentication Biometrics Lecture 4 Authentication Authentication ensures: Someone are permitted to access the asset Someone are who they say they are understandCredentials: Something they are Something they have Something they know Username &amp; Password First step: identification - you announce who you are Second step: authentication - you prove that you are who you claim to be. Time of check to time of use (TOCTTOU) 这是一个软件设计上的竞争条件 解决方法：The operating system checks a user's identity at the start of a session but uses the identity to make access control decisions later on during the session Password Problems with passwords: Forget Guess Spoofing and phishing Comprimised password files Keylogging Weak password [UNDERSTAND] Password Policies Certain length, certain types of characters / No dictionary words / Change regularly / No previously used passwords Storing passwords Use a one-way hash function Password / Shadow Files that stored passwords are read protected Cracking Passwords Offline: you have a copy of the password hash locally try lots of possible passwords and see if we have a hash collision with a password list brute force dictionary attack Online: you do not have the hash, and are instead attempting to gain access to an actual login terminal usually attempted with phishing [UNDERSTAND] Password Salting (improve security) password salting Cracking multiple passwords is slower - a hit is for a single user Prevents rainbow table attacks (reverse hash directly) But salting has no effect on the speed of cracking a single password. Multi-Factor Authentication Password are something you know MFA conbines something you know with something you have Text code to mobile Google/Microsoft Authenticator One time password USB devices Biometrics Combine something you know with something you are Fingerprint Retina recognition Voice... Accuracy of a biometric system is important: FP rate FN rate","link":"/wiki/Lecture%20Note/COMP3052%20Computer%20Security/CS5/"},{"title":"COMP3052 Computer Security 2 -- Computer Security Foundations","text":"Lecture 3 Foundations Key concept Security Computer Security Computer Security Fundamental Dilemma Data vs Information Problem of inference [IMPORTANT] 3.4 Security Design: Principles Focus of Control (1st Design Decision) Complexity vs Assurance (2nd Design Decision) Centralised or Decentralised Controls (3rd Design Decision) The layer Below (4th Design Decision) Lecture 3 Foundations Key concept Security Security is about the protection of assets Knowledge of assets and their values are vital Protection measures: prevention: taking measures that prevent your assets from being damaged detection: taking measures that allow you to detect when an asset has been damaged, how it has been damaged, and who has caused the damage reaction: taking measures that allow you to recover your assets or to recover from damage to your assets Computer Security Definition: Deals with the prevention and detection of unauthorised actions by users of a computer system Six aspects ([IMPORTANT] three main: CIA): Confidentiality (prevention of unauthorised disclosure of information) privacy - protection of personal data secrecy - protection of data of an organization Integrity (prevention of unauthorised modification of information) deals with the prevention of unauthorised writing assurance that data remains unmodified Availability (prevention of unauthorised withholding of information or resources) The property of being accessible and usable upon demand by an authorised entity Denial of Servie (DoS) is a way of prevention of availability, or availability wish to prevent DoS. Definition of DoS: The prevention of authorized access to resources or the delaying of time-critical operations Accountability (Users should be held responsible for their actions) System should identify and authenticate users audit information must be selectively kept and protected so that actions affecting security can be traced to the responsible party Non-repudiation (不可否认性) provide unforgeable evidence (不可欺骗的证据) evidence that is verifiable by a third party Two way nonrepudiation of origin - sender identification nonrepudiation of delivery - delivery confirmation Reliability against (accidental failure) difference with safety: impact of system failures on their environment 统一概念：可信任性(dependability)，将safety, reliability, integrity and availability作为dependability的几个方面 Dependability: the property of a computer system such that reliance can justifiably be placed in the service it deliver Computer Security Fundamental Dilemma Security-unaware users have specific security requirements but usually no security expertise trade-off between security and ease of use Security mechanism need increased computational resources Security interferes with working patterns of users Managing security is tired - purchasers often choose best GUI Data vs Information Security is about controlling access to information and resources, but this can be difficult, thus controlling access to data is more viable. Data - Means to represent information Information - (Subjective) Interpretation of data Problem of inference focusing on data can still leave information vulnerable Carefully chosen queries can narrow down who has what condition [IMPORTANT] 3.4 Security Design: Principles Focus of Control Complexity vs. Assurance Centralised or Decentralised Controls Layered Security Focus of Control (1st Design Decision) should protection mechanism focus on: data, operations, or users? Complexity vs Assurance (2nd Design Decision) Do you prefer simplicity and higher assurance to a feature-rich security environment? Centralised or Decentralised Controls (3rd Design Decision) Should the tasks of defining and enforcing security be given to a central entity or be left to individual components in a system? central - could mean bottleneck distributed solution - more efficient but harder to manage The layer Below (4th Design Decision) How can you prevent an attacker getting access to a layer below the protection mechanism? A good security layer built upon an insucure layer is useless.","link":"/wiki/Lecture%20Note/COMP3052%20Computer%20Security/CS4/"},{"title":"COMP3052 Computer Security 1 -- Intro","text":"Lecture 1,2 Intro &amp; Motivation On Security (past vs now) Attacks &amp; Attackers Security Management Security Policy [UNDERSTAND] Measuring security Risk and Threat Analysis Asset Vulnerabilities Threats Risk Lecture 1,2 Intro &amp; Motivation On Security (past vs now) Past: security originally focus on systems with single, or few users Now: security focus on ubiquitous end systems interconnected by networks danger of attacks from 'un-trustworthy' nodes attacks both remotely and locally ## Attacks &amp; Attackers status quo: hackers -&gt; organized crime website -&gt; personal data harvester virus -&gt; trojans and DoS Complexity of system increase -&gt; while our understanding of this cannot Security Management Protecting assets of an organization is the responsibility of management assets: sensitive information - product plans, customer records Security measures must have full support of senior management Security awareness programmes (这个不是程序的意思) convey the information (相当于安全培训) ensure every member know: why security is important what is expected of each member which good practices should follow User is not enemy, developers need more awareness (开发人员也要安全培训)、 Security Policy definition: a statement that defines the security objectives of an organization what needs to be protected how this should be achieved understandcontent / objectives: Security Policy Objective(安全策略目标): 是一个用于保护可识别资源(protect identifiable resource)，防止未授权使用(unauthorized use)的声明 Organisational Security Policy(有组织的安全策略): The set of laws, rules, and practices that regulate how an organization manages, protects and distribute resources to achieve specified security objectives (为了确保组织管理达到特定的安全策略目标) Automated Security Policy(自动的安全策略): The set of restrictions and properties that specify how a computing system prevents information and computing resources from being used to violate an organizational security policy (为了确保计算资源不违背有组织的安全策略) [UNDERSTAND] Measuring security Measures only exist for some aspects of security - how? Product Security: number of security flaw (bugs), the number of interfaces to outside callers - 有争议的 System Security: number of accounts with system privileges or the number of accounts with weak passwords, number of open ports, service accessible from outside, running system has vulnerability Cost of an Attack: 在攻击的时候，攻击者需要投入的时间，比如找漏洞 在攻击的时候需要的花费（计算周期+特殊装备） 攻击需要的知识(knowledge) Cost of Assets Risk and Threat Analysis IT risk analysis can be applied in: All information asset IT infrastructure development of a product or system Risk - Possibility of an incident or attack to cause damage to your enterprise, informal calculation: \\(Risk = Assets \\times Vulnerabilities \\times Threat\\) Asset In an IT system, assets include: hardware: laptops, servers, routers ... software: applications, operating systems, database management systems, source code... data and information - essential data for running and planning your business, design documents, digital content, data about your customer reputation Features: Identification of assets is easy and straightforward Measurement of asset values is a challenge data, information, and reputation is more difficult to measure Vulnerabilities Definition: weaknesses of a system that could be accidentally or intentionally exploited to damage assets Typical vulnerability include: badly configured privileged account program with unnecessary privileges programs with known flaws weak access control weak firewall configuration Threats Definition: actions by adversaries who try to exploit vulnerabilities to damage assets Ways of identifying threats Categorisation by damage done to assets: spoofing identities(欺骗身份认证) Tampering with data(数据篡改) Repudiation(抵赖): 用户否认执行了带有攻击性的操作 Information disclosure Denial of Service(拒绝服务攻击) Elevation of privilege(提高特权) Identify threats by source who? - member of organization or an outsider? a contractor or a former member access the system directly or remotely? Analysis of attack execution (Attack graphs) Risk [UNDERSTAND] Quantiative Risk Analysis pro: probability theory based on mathematical theory con: quality of results depends on quality of inputs not always feasible [UNDERSTAND] Qualitative Risk Analysis pro: more applicable con: scaling based on judgements of security experts Countermeasures - risk mitigation The result of a risk analysis is a prioritized list of threats, together with recommended countermeasures to mitigate risk why risk analysis is not ideal? take time while world outside keeps changing cost high opt for baseline protection as an alternative analyse typical cases and recommends security measures","link":"/wiki/Lecture%20Note/COMP3052%20Computer%20Security/CS3/"},{"title":"COMP3056 Computer Vision 2 -- SIFT","text":"Table of Contents Point Features: SIFT [IMPORTANT] SIFT Overview [UNDERSTAND] Detailed Steps Step 1: Scale-space extrema detection - Scale Invariant Step 2: Keypoint localization - Translation Invariant Step 3: Orientation assignment - Orientation/Rotation Invariant Step 4: SIFT Descriptor - Illumination Invariant [IMPORTANT] Properties [UNDERSTAND] Uses / Applications Point Features: SIFT Feature Descriptor: Feature Vectors that describes sections of an imagePurpose of SIFT: Create a good feature detection/description algorithm that is invariant to scale, translation, rotation and illumination changesScale Invariant Feature Transform (SIFT): Transform image data into scale-invariant coordinates relative to local features [IMPORTANT] SIFT Overview 1-2 Sentences per step enough Scale-space extrema detection - For Scale Invariance Search over all scales and image locations Detect points that are invariant to scale and orientation Keypoint localization - For Translation Invariance A model is fit to determine the location and scale Keypoints are selected based on measures of their stability Orientation assignment - For Rotation/Orientation Invariance Compute best orientation for each keypoint region Keypoint descriptor - For Illumination Invariance Use local image gradients at selected scale and rotation to describe each keypoint region [UNDERSTAND] Detailed Steps Step 1: Scale-space extrema detection - Scale Invariant Get rid of some details while not introducing new false details - Using Gaussian Blur Generate scale space octaves of the original image Each octave's image size is half of the previous one Within an octave, images are progressively blurred using the Gaussian Blur operator Step 2: Keypoint localization - Translation Invariant Get rid of low contrast keypoints or keypoints lied along an edge - Comparing DoG value with the preset threshold Produce DoGs using two consecutive images in an octave for all octaves Detect the maxima/minima in the DoG images (The greatest or least one of all neighbors, 8 surrounding pixels, 9 upper pixels, and 9 lower pixels) Reject the keypoints if they had a low contrast or if they were located on an edge Step 3: Orientation assignment - Orientation/Rotation Invariant Figure out the most prominent orientation in the region and assign it to the keypoint - Calculating gradient magnitude and direction of the region around the key point To assign an orientation we calculate the gradient magnitude and direction of a small region around the keypoint Using the histogram, the most prominent gradient orientation is identified Peak of the histogram Assign it to the keypoint Step 4: SIFT Descriptor - Illumination Invariant Compute a descriptor for the local image region(window) around each keypoint Region normalization Rotate the window to standard orientation Scale the window size based on the scale at which the point was found Full version: Divide the 16x16 window into a 4x4 grid of cells Within the 4x4 cell, the orientations and gradient magnitudes are calculated Put these orientations into an 8 bin histogram (the amount added to the bin depends on the magnitude of the gradient) 16 cells * 8 orientations = 128 dimensional descriptor Normalize the vector Clamp all vector values &gt; 0.2 to 0.2 Renormalize [IMPORTANT] Properties Invariance To be robust to intensity value changes Use gradient orientations To be scale invariant Estimate the scale using scale-space extrema detection Calculate the gradient after Gaussian smoothing with this scale To be orientation invariant Rotate the gradient orientations using the dominant orientation in a neighborhood To be illumination invariant Working in gradient space, so robust to I = I + bbNormalize vector to [0..1], robust to I = αl brightness changes Clamp all Vector values &gt; 0.2 to 0.2, robust to \"non-linear illumination effects\" (No need to remember the specific number like 0.2, just remember the idea) Fast and efficient Can run in real time Lots of code available Can handle Changes in viewpoint, up to about 60°out of plane rotation Significant changes in illumination, sometimes even day vs. night [UNDERSTAND] Uses / Applications Pose estimation 3D reconstruction Object recognition Image retrieval","link":"/wiki/Lecture%20Note/COMP3065%20Computer%20Vision/CV3/"},{"title":"COMP3052 Computer Security -- Preface","text":"Preface This course includes computer network + computer security + web development + linux + windows + software vulnerability + database + cryptography + metamorphic security. So if you don't understand something, it is pretty normal. My suggestions for this course would be: Memorise and understand the abbreviations Look up more materials online to help you understand Learn to summarise Contributor Tragic Master 冬堂昀殊","link":"/wiki/Lecture%20Note/COMP3052%20Computer%20Security/CS1/"},{"title":"COMP3052 Computer Security -- Abbreviations","text":"Abbreviation / Terminology Abbreviation Full name 中文 Source ACL Access Control List 访问控制列表 AH Authentication Header 认证头 IPSec ARP Address Resolution Protocol 地址解析协议 IPv4 AS Authentication Server 鉴别服务器 CIA Confidentiality, Integrity, Availability 机密性，完整性，可用性 DAC Discretionary Access Control 自主访问控制 Linux/Unix Security DC Domain Controller 域控制器 Windows Security DMZ Demilitarized Zone 隔离区 Firewalls DNS Domain Name System 域名系统 TCP/IP DoS Denial of Service 拒绝服务 DDoS Distributed Denial of Service 分布式拒绝服务 ECDHE Elliptic Curve Diffie-Hellman Ephemeral 短暂椭圆曲线迪菲赫尔曼（算法 Crypto ESP Encapsulated Security Payload 封装安全载荷 IPSec FS File System 文件系统 GINA Graphical Identification and Authentication 图像识别和验证 KDC Key Distribution Center 密钥分配中心 LSA Local Security Authority 本地安全认证 Windows Security Subsystem NSA National Security Agency past paper 2021 NTLM NT LAN Manager 问询/应答身份验证协议 SAM Security Account Manager 安全账户管理员 Windows Security Subsystem SPI Security Parameter Index 安全参数串行 IPSec SSL Secure Socket Layer 安全套接层 SSL/TLS TCB Trusted Computing Base 可信计算基 TGS Ticket Granting Server 票据授予服务器 TGT Ticket Granting Ticket 票据授予票据 TLS Transport Layer Security 安全传输层 SSL/TLS TOCTTOU Time-of-Check to Time-of-Use 检查与使用时差错误 TTL Time To Live 生存时间 Winlogon Windows Logon Process Windows NT用户登录程序 XSS Cross-site Scripting 跨站脚本 XSRF Cross-site Request Forgery 跨站请求伪造","link":"/wiki/Lecture%20Note/COMP3052%20Computer%20Security/CS2/"},{"title":"MySQL Cheatsheet","text":"Classification MySQL data types Numerical type Date/time tyoe String type MySQL DDL &amp; DML MySQL DQL SELECT WHERE IN BETWEEN...AND... NOT LIKE Regular Expression NULL (这个比较特殊） NULL != ' ' (empty string) Sort EXISTS Aggregate Functions AVG/COUNT/SUM/MAX/MIN GROUPING HAVING LIMIT DISTINCT (remove repeated element) UNION (合并查询结果集) INTERSECT (交集) EXCEPT (差集) MySQL Subquery MySQL Table Association INNER JOIN LEFT JOIN RIGHT JOIN MySQL in terminal Reference Classification Data Definition Language (DDL) 1CREATE 1DROP 1ALTER Data Manipulation Language (DML) 1INSERT 1DELETE 1UPDATE Data Query Language (DQL) 1SELECT 1WHERE Data Control Language (DCL) 1GRANT 1REVOKE Transaction Control Language (TCL) 1COMMIT 1ROLLBACK ## MySQL data types Numerical type Integer INTEGER/INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT Fixed-point DECIMAL, NUMERIC Floating-point FLOAT, DOUBLE Date/time tyoe DATE, DATETIME, TIMESTAMP, TIME, YEAR String type CHAR, VARCHAR, BINARY, VARBINARY, BLOB, TEXT, ENUM, SET MySQL DDL &amp; DML Create table 1234567CREATE table player ( id INT, name VARCHAR(100), level INT, exp INT, gold DECIMAL(10, 2)); Insert (single) Data 1INSERT INTO player (id, name, level, exp, gold) VALUES (1, '张三', 1, 1, 1); read data 1SELECT * from player; Insert (multiple) data 1INSERT INTO player (id, name) VALUES (2, '李四'), (3, '王五') （blank means NULL, because we did not specify the default data） Modify the structure of table 1234-- 将level的默认值设置为1ALTER TABLE player MODIFY LEVEL INT DEFAULT 1;-- 将name的类型改为VARCHAR(200)ALTER TABLE player MODIFY COLUMN name VARCHAR(200); Update the data in the table 123456-- 只修改李四的数据UPDATE player set level = 1 where name = '李四';-- 全部修改（比较危险）UPDATE player set level = 1;-- 修改多列值UPDATE player set exp=0, gold=0; create index 12345-- unique: 唯一索引-- full text: 全文索引-- spacial: 空间索引CREATE [UNIQUE|FULL TEXT|SPATIAL] INDEX index_name ON table_name (index_col_name, ...) delete index 1drop index index_name on table_name alter table by inserting index 1alter table table_name add index name_index (col_name) MySQL DQL SELECT 12345SELECT name, levelFROM playerWHERE level = 1ORDER BY goldLIMIT 3; WHERE 12345SELECT * FROM player where level = 1;SELECT * FROM player where level &gt; 1;SELECT * FROM player where level &gt; 1 and level &lt; 5;-- Priority: NOT &gt; AND &gt; ORSELECT * FROM player where level &gt; 1 AND (level &lt; 5 OR exp &gt; 1) AND exp &lt; 5; IN 1SELECT * FROM player WHERE level IN (1, 3, 5); BETWEEN...AND... 1SELECT * FROM player WHERE level BETWEEN 1 AND 10; NOT 1SELECT * FROM player WHERE level NOT BETWEEN 1 AND 10; LIKE char match % any number of any character _ any one character 1SELECT * FROM player WHERE name LIKE '王%'; Regular Expression char match . any character ^ begin $ end [abc] any character inside bracket [a-z] any character in range(a, z) A | B A or B 12345SELECT * FROM player WHERE name REGEXP '[0-9]';-- find name start with 王 and only two character (second character-- can be anything)SELECT * FROM player WHERE name REGEXP '^王.$'; NULL (这个比较特殊） 12SELECT * FROM player WHERE email is NULL;-- note the language should not be: SELECT * FROM player WHERE email = null NULL != ' ' (empty string) 1SELECT * FROM player WHERE email = '' or email is NULL; Sort 12345-- sort by level in descending orderSELECT * FROM player ORDER BY level DESC;-- sort by level in descending order, if order is same,-- then exp in ascending orderSELECT * FROM player ORDER BY level DESC, exp ASC; EXISTS to know whether a subquery exists. 0 means no, and 1 means yes. 1SELECT EXISTS(SELECT * FROM player WHERE level &gt; 10) Aggregate Functions AVG/COUNT/SUM/MAX/MIN 1SELECT AVG(level) FROM player GROUPING 12SELECT sex, count(*) FROM player GROUP BY sex;SELECT level, count(level) FROM player GROUP BY level; HAVING 1SELECT level, count(level) from player GROUP BY level HAVING COUNT(level) &gt; 4 LIMIT 123456SELECT SUBSTR(name, 1, 1), COUNT(SUBSTR(name, 1, 1)) from player GROUP BY SUBSTR(name, 1, 1)HAVING COUNT(SUBSTR(name, 1, 1)) &gt;= 5ORDER BY SUBSTR(name, 1, 1) DESC-- we want the first 3 elementsLIMIT 3 DISTINCT (remove repeated element) 1SELECT DISTINCT sex from player UNION (合并查询结果集) 12345678910SELECT * FROM player where level BETWEEN 1 AND 3UNIONSELECT * FROM player WHERE exp BETWEEN 1 AND 3;-- we want to keep record that satisfy both conditions-- because by default UNION remove repeated elementSELECT * FROM player WHERE level BETWEEN 1 AND 3UNION ALLSELECT * FROM player WHERE exp BETWEEN 1 AND 3; INTERSECT (交集) 123SELECT * FROM player WHERE level BETWEEN 1 AND 3INTERSECTSELECT * FROM player WHERE exp BETWEEN 1 AND 3 EXCEPT (差集) 123SELECT * FROM player WHERE level BETWEEN 1 AND 3EXCEPTSELECT * FROM player WHERE level BETWEEN 1 AND 3 MySQL Subquery sometimes we need one query to be the condition of another query. 12345678910111213SELECT * FROM player WHERE level &gt; (SELECT AVG(level) FROM player)-- remember to use aliasSELECT level, ROUND(SELECT AVG(level) FROM player) as average, level - ROUND(SELECT AVG(level) from player) as diffFROM player-- can also used in creating new tablecreate table new_player select * from player where level &lt; 5;-- insert new datainsert into new_player select * from player where level between 6 and 10; MySQL Table Association INNER JOIN 12345-- display what both table have-- by linking the foreign keyselect * from playerinner join equipon player.id = equip.player.id LEFT JOIN 123456789-- display what left table have-- by linking the foreign key-- if right table did not have the info-- will fill NULL-- (under this scenario, left table will display fully)select * from playerleft join equipon player.id = equip.player.id RIGHT JOIN 123456789-- similarly, display what right table have-- by linking the foreign key-- if left table did not have the info-- will fill NULL-- (under this scenario, right table will display fully)select * from playerright join equipon player.id = equip.player.id MySQL in terminal Login (local) Login the localhost mysql database, -uspecifies the username, -pspecify to use password to login 1$ mysql -u root -p Login (remote) Login the remote mysql database, -hspecifies the IP address of the host machine 1$ mysql -h 10.211.55.5 -u root -p Switch database 1mysql&gt; use database_name; Show database 1mysql&gt; show databases; Create a database 1mysql&gt; create database game; Create tables 1234567mysql&gt; create table player ( id INT, name VARCHAR(100), level INT, exp INT, gold DECIMAL(10, 2) &lt;- 长度为10保留两位小数的十进制数值) Describe the structure of the table 1mysql&gt; DESC player; CRUD 1mysql&gt; SELECT/UPDATE/DELETE/ALTER ... exit 1mysql&gt; exit; export database 1$ mysqldump -u root -p game player &gt; player.sql import database 1mysql&gt; mysql -u root -p game &lt; game.sql Reference 【一小时MySQL教程 Geekhour】https://www.bilibili.com/video/BV1AX4y147tA/?share_source=copy_web&amp;vd_source=590654268d829d1b7b4303295980cd78","link":"/wiki/MySQL/mysql/"},{"title":"COMP3056 Computer Vision -- Preface","text":"Preface The last course for the undergraduate ~ Contributor Tragic Master 冬堂昀殊 stephen #LOSiAriana","link":"/wiki/Lecture%20Note/COMP3065%20Computer%20Vision/CV1/"},{"title":"Git Cheatsheet Part 4: Change, Restore and Reset","text":"Table of Contents 撤销和恢复 修改信息查看 撤销和恢复 移动一个文件到新的为位置 1git mv &lt;file&gt; &lt;new-file&gt; 从工作区和暂存区删除一个文件，然后暂存删除操作 1git rm &lt;file&gt; 只从暂存区删除一个文件，工作区保留 1git rm --cached &lt;file&gt; 恢复一个文件到之前的版本 1git checkout &lt;file&gt; &lt;commit-id&gt; 创建一个新的提交，用来撤销指定的提交，后者的所有变化都将被前者抵消，并且应用于当前分支 1git revert &lt;commit-id&gt; 重置当前分支的HEAD为之前的某个提交，并且删除所有之后的提交。--hard参数表示重置工作区和暂存区，--soft参数表示重置暂存区，--mixed参数表示重置工作区 1git reset --mixed &lt;commit-id&gt; 撤销暂存区的文件，重新放回工作区（git add的反向操作） 1git restore --staged &lt;file&gt; 修改信息查看 列出还未提交的新的或修改的文件 1git status 查看提交历史，--oneline可以忽略 1git log --oneline 查看未暂存的文件更新了哪些部分 1git diff 查看两个提交之间的差异 1git diff &lt;commit-id&gt; &lt;commit-id&gt;","link":"/wiki/Git/git4/"},{"title":"C# 基础 - 内置类型","text":"基本数据类型 类型 含义 取值范围 精度 sbyte 有符号8位整数 -128到127 8位 byte 无符号8位整数 0到255 8位 short 有符号16位整数 -32768到32767 16 ushort 无符号16位整数 0到65535 16 int 有符号32位整数 -2147483648到2147483647 32 uint 无符号32位整数 0到4294967295 32 long 有符号64位整数 -9223372036854775808到9223372036854775807 64 ulong 无符号64位整数 0到18446744073709551615 64 float 单精度32位浮点值 -3.4 x 1038 到 +3.4 x 1038 32 double 双精度64位浮点值 64 decimal 表示128位数据类型 ( 7.9 x 1028 - 7.9 x 1028) / (100 - 28) 128 bool 表示一个布尔值 true / false, 1 byte 8 bit char 表示一个UTF-16字符 U+0000 到 U+FFF 16位 内置类型 内置值类型 c#类型关键字 .NET类型 bool System.Boolean byte System.Byte sbyte System.SByte char System.Char decimal System.Decimal double System.Double float System.Single int System.Int32 uint System.UInt32 nint System.IntPtr nuint System.UIntPtr long System.Int64 ulong System.UInt64 short System.Int16 ushort System.UInt16 内置引用类型 c#类型关键字 .NET类型 object System.Object string System.String dynamic System.Object","link":"/wiki/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/CSharp/CSharpDataType/"},{"title":"Git Cheatsheet Part 3: Remote Repository","text":"Table of Contents 远程仓库 远程仓库 添加远程仓库 1git remote add &lt;remote-name&gt; &lt;remote-url&gt; 查看远程仓库 1git remote -v 删除远程仓库 1git remote rm &lt;remote-name&gt; 重命名远程仓库 1git remote rename &lt;old-name&gt; &lt;new-name&gt; 从远程仓库拉取代码 1git pull &lt;remote-name&gt; &lt;branch-name&gt; fetch默认远程仓库(origin)当前分支的代码，然后合并到本地分支 1git pull 将本地改动的代码rebase到远程代码最新的代码上（为了有一个干净的线性的提交历史） 1git pull --rebase 推送代码到远程仓库（然后再发起pull request） 1git push &lt;remote-name&gt; &lt;branch-name&gt; 获取所有远程分支 1git fetch &lt;remote-name&gt; 查看远程分支 1git branch -r fetch某一个特定的远程分支 1git fetch &lt;remote-name&gt; &lt;branch-name&gt;","link":"/wiki/Git/git3/"},{"title":"Screen 命令","text":"Table of Contents Overview 安装Screen 创建Screen 强制创建Screen 将指定的Screen作业在后台工作 显示当前所有Screen作业 恢复、链接Screen对话 尝试恢复Screen对话 也用于恢复名字为name的会话 删除Screen对话 Garbage Collection Overview Screen 的状态有两种，Attached 和 Detached，分别表示前台运行和后台运行。 使用 screen -r 会话名 (或者编号)可以将 Detached 状态的屏幕会话状态修改为 前台运行 ，并同时切换到这个会话中。如果会话状态已经是Attached状态，使用命令 screen -r 会话名 (或者编号)将会报错 安装Screen 12345$ sudo apt-get install screen$ sudo yum install screen// 验证$ screen -v 创建Screen 1$ screen -S &lt;会话名&gt; 强制创建Screen 12// 即使目前已在作业中的screen作业，仍强制建立新的screen作业。$ screen -m &lt;会话名&gt; 将指定的Screen作业在后台工作 1234// 将这个会话调为后台工作$ screen -d &lt;会话名&gt;// 将当前的会话调为后台工作，并恢复这个会话$ screen -d -r &lt;会话名&gt; 显示当前所有Screen作业 1$ screen -ls 恢复、链接Screen对话 12// 连接 screen_id 为 2276 的 screen终端$ screen -r 2276 尝试恢复Screen对话 12// 先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。$ screen -R 2276 也用于恢复名字为name的会话 12// 当上面方法不行的时候$ screen -x &lt;会话名&gt; 删除Screen对话 1$ screen -S &lt;会话名&gt; -X quit Garbage Collection 12$ screen -wipe// 检查目前所有的screen作业，并删除已经无法使用的screen作业。","link":"/wiki/Linux/screen_manpage/"},{"title":"COMP3056 Computer Vision 1 -- Image Regions and Patches","text":"Table of Contents Segments and Patches Usage of Segments and Patches Features and Feature Vector Classification of Features Image Derivative (只需要理解sobel filter) [IMPORTANT] Histogram of Oriented Gradients (HoG) The steps of HoG Segments and Patches Segments is irregular, or rectangular Patches always rectangular Usage of Segments and Patches Track objects use different views to reconstruct 3D detect object classes and recognize specific objects using pre-stored model Features and Feature Vector Feature is a piece of information about the content of an imageFeature vector refers to a vector that contains the concatenation of multiple features in an image. Classification of Features Color Features Texture Features Local Binary Patterns (LBP) For each center pixel \\(p_c\\), create an 8-bit number \\(\\{b_1, b_2, b_3, b_4,b_5, b_6, b_7, b_8\\}\\), for \\(i \\in [1, 8]\\), the local binary pattern will be: $$b_i = \\left\\{\\begin{array}{rcl}0 & & (p_i \\leq p_c)\\\\1 & & (p_i \\gt p_c)\\end{array}\\right.$$ LBP Feature Vector Divide the patch into cells e.g. 16 x 16 pixels per cell Compute local path description number of each pixel Histogram these numbers over each cell 将上面的八位二进制转成十进制 所以ppt上说256-d dimension Normalize each histogram (optional) Concatenate histograms to make the feature vector Shape Features focus on image gradient measures Image Derivative (只需要理解sobel filter) Definition of Sobel Filter: The calculation process for Sobel Filter: [IMPORTANT] Histogram of Oriented Gradients (HoG) The steps of HoG Divide the patch into small cells Define slightly larger blocks, covering several cells Compute gradient magnitude and orientation at each pixel Compute a local weighted histogram of gradient orientations for each cell, weighting by some function of magnitude. The histogram is a vector of 9 bins corresponding to angles 0, 20, 40, 60 … 160 A bin is selected based on the direction(角度), and the vote (the value that goes into the bin) is selected based on the magnitude 先根据角度算每个格子的占比，下图中左红色圈代表角度为10度，介于0-20度之间，10 = 0 * 0.5 + 20 * 0.5，知道这个占比之后按照占比将右边圈代表梯度大小，则0 bin里是4 * 0.5 = 2, 2 bin里是4 * 0.5 = 2. 遇到边界的（角度在160-180且需要分配的），第二个分配到0 bin里。下图左绿色圈代表角度为165度，165 = 160 * 0.75 + 180 * 0.25，则160 bin里是85 * 0.75 = 63.75, 0 bin（本来应该是180bin但没这个bin换成0bin）为85 * 0.25 = 21.25。 Concatenate histogram entries to form a HoG vector for each blockP.S. 上图中一个block里有四个cell，一个cell生成9*1的histogram如下图，那么四个cell的histogram直接横向拼接接为36*1的element vector Normalize vector values by dividing by some function of vector length （单个元素除以全部元素平方和）","link":"/wiki/Lecture%20Note/COMP3065%20Computer%20Vision/CV2/"},{"title":"Git Cheatsheet Part 2: Command and Branches","text":"Table of Contents 添加和提交 分支 合并分支 Rebase 添加和提交 添加一个文件到仓库 1git add &lt;file&gt; 添加所有文件到仓库 1git add . 提交所有暂存区的文件到仓库 1git commit -m &quot;message&quot; 提交所有已经修改的文件到仓库 1git commit -am &quot;message&quot; 分支 查看所有本地分支 12# 当前的分支前会有一个`*`git branch 查看远程分支 1git branch -r 查看所有分支 1git branch -a 创建一个新分支 1git branch &lt;branch-name&gt; 切换到指定分支，并更新工作区 1git checkout &lt;branch-name&gt; 创建一个新分支，并切换到该分支 1git checkout -b &lt;branch-name&gt; 删除一个已经合并的分支 1git branch -d &lt;branch-name&gt; 删除一个分支，不管是否合并 1git branch -D &lt;branch-name&gt; 给当前的版本打上标签，通常用于版本发布 1git tag &lt;tag-name&gt; 合并分支 合并分支a到分支b，有两种模式，第一种是禁用Fast forward模式，参数为--no-ff，合并后的历史有分支，能看出曾经做过合并 1git merge --no-ff -m &quot;message&quot; &lt;branch-name&gt; 第二种是使用Fast forward模式，参数是--ff，合并后历史会变成一条直线。原来是直接将仓库里的HEAD指针指向要merge的分支上。 1git merge --ff -m &quot;message&quot; &lt;branch-name&gt; 第三种是使用squash进行压缩，参数是--squash，是用来把一些不必要commit进行压缩，比如说，你的feature在开发的时候写的commit很乱，那么我们合并的时候不希望把这些历史commit带过来，于是使用–squash进行合并。 1git merge --squash &lt;branch-name&gt; 三种方式的区别可以查看下图作为参考 Rebase Rebase操作可以将本地未push的分支提交历史整理成直线，假设当前有两个分支，master和feature。 官方原文解释为：当执行rebase操作时，git会从两个分支的共同祖先开始提取待变基分支上的修改，然后将待变基分支指向基分支的最新提交，最后将刚才提取的修改应用到基分支的最新提交的后面。 具体操作如下图： 当执行rebase命令时： 12git checkout featuregit rebase master 此举主要用于我们在分支的feature上开发了一段时间，准备从主干上拉一下最新变动，下图为变基之后的提交节点图 结合例子看一下官方原文：当在feature分支上执行git rebase master时，git会从master和featuer的共同祖先B开始提取feature分支上的修改，也就是C和D两个提交，然后将feature分支指向master分支的最新提交上，也就是M。最后把提取的C和D接到M后面 注意：这里的将C和D接到M后面的接法，会依次拿M和C、D内容分别比较，处理冲突后生成新的C’和D’ 为什么叫rebase？ feature分支是基于master分支的B拉出来的分支，feature的基底是B。而master在B之后有新的提交，就相当于此时要用master上新的提交来作为feature分支的新基底。","link":"/wiki/Git/git2/"},{"title":"Git Cheatsheet Part 1: Overview","text":"Table of Contents 初始化 创建仓库 Git的四个区域 Git的三种状态 特殊文件(夹) 基本分支 初始化 初始化设置用户名和邮箱 123git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@email.com&quot;git config --global credential.helper store 创建仓库 创建一个新的本地仓库（忽略project-name则在当前目录创建） 1git init &lt;project-name&gt; 下载一个远程仓库 1git clone &lt;url&gt; Git的四个区域 工作区 (working directory): 就是你在电脑里看到的目录 暂存区 (Stage/Index): 一般存放在.git目录下面 本地仓库 (Repository): 工作区有一个隐藏目录的.git，这个不算工作区，而是Git的版本库 远程仓库 (Remote): 托管在远程服务器上的仓库 Git的三种状态 已修改 (Modified): 修改了文件，但没保存到暂存区 已暂存 (Staged): 把修改后的文件放到了暂存区 已提交 (Commited): 把暂存区的文件提交到本地仓库 特殊文件(夹) .git: Git仓库的元数据和对象数据库 .gitignore: 配置不需要提交到仓库的文件 .gitattribute: 指定文件的属性，比如换行符 .gitkeep: 使得空目录也能提交到仓库 .gitmodules: 记录子模块的信息 .gitconfig: 记录仓库的配置信息 基本分支 main: 默认主分支 origin: 默认远程仓库 HEAD: 指向当前分支的指针 HEAD^: 上一个版本 HEAD~4: 上四个版本","link":"/wiki/Git/git1/"},{"title":"COMP3056 Computer Vision 3 -- Image Stitching","text":"Table of Contents Image Stitching Geometric Transformations Basic Transformations Combined Transformation Image Stitching [IMPORTANT] Idea of Stitching Motion Models [IMPORTANT] RANSAC Image Warping [UNDERSTAND] Forward Warping [UNDERSTAND] Inverse Warping [UNDERSTAND] Which one is better - Usually inverse Image Blending [IMPORTANT] Pyramid Blending Detailed Steps: [NOT IMPORTANT] Multiband Blending [IMPORTANT] Recognizing Panoramas Image Stitching Geometric Transformations Basic Transformations Translation Rotation Scale Aspect Ratio Shear Combined Transformation Euclidean transform = Translation + Rotation (1+2 DOF) 刚体变换/欧氏距离变换- 3 Degree Of Freedom (DOF) Similarity transform = Translation + Rotation + Scale (1+2+1 DOF) 相似变换 - 4 DOF Affine transform = Translation + Rotation + Scale + Aspect Ratio + Shear 仿射变换 - 6 DOF Projective transform - Homogeneous Coordinates 投影变换- 8 DOF Image Stitching [IMPORTANT] Idea of Stitching Take a sequence of images from the same position. Rotate the camera about its optical center Or hold the camera and turn the body without changing the position if there are no tripods. To stitch two images: compute transformation between the second image and the first. Extract interest points Find Matches Compute Shift (warp) the second image to overlap with the first. Blend the two together to create a mosaic. If there are more images, repeat step 2 to 4. Motion Models Translation = 2 DOF - 1 Pairs Similarity = 4 DOF - 2 Pairs Affine = 6 DOF - 3 Pairs Projective (Homography) = 8 DOF - 4 Pairs [IMPORTANT] RANSAC Random Sample Consensus 随机样本一致性算法 RANSAC loop for estimating homography Select 4 feature pairs (at random) Compute homography \\(H\\)(exact) Compute inliers where \\(||p_i ', H p_i|| &lt; \\varepsilon\\) Keep the largest set of inliers Re-compute least squares H estimate using all of the inliers The idea of fitting a RANSAC line: Use the biggest set of inliers and do the least-square fit Image Warping describe the idea of two warping methodsChange every pixel locations to create a new image (global)Transform function \\(x' = h(x)\\)Source image \\(f(x)\\)Transformed image \\(g(x') = f(h(x))\\) Change the domain of image function [UNDERSTAND] Forward Warping Send each pixel \\(f(x)\\) from the original image (RGB value) to the dest image: \\(x' = h(x)\\) in\\(g(x')\\)If pixel lands \"between\" 2 pixels, then add \"contribution\" to several neighboring pixels, normalize later (splatting) [UNDERSTAND] Inverse Warping Get each pixel \\(g(x')\\) from the transformed image to the source image: \\(x=h^{-1}(x')\\) in \\(f(x)\\)If pixel comes from \"between\" 2 pixels, then resample color value from the interpolated source image Possible interpolation filters: Nearest neighbor Bilinear bilinear [UNDERSTAND] Which one is better - Usually inverse https://blog.csdn.net/baoyongshuai1509/article/details/109013703 Because the result of forward warping might show some holes like gray marks in the figure. That is no pixels are mapped to this position after warping. While some points may fall into the same position in the new map, as shown in the red box below. This is because of the discretization of image pixels. The transform function is usually neither injective nor surjective, so the non-integral value after warping will be rounded off, so not every pixel in the original image will be assigned a pixel value in the new image. Similarly, a single pixel in the new image may correspond to multiple pixels in the original image By using inverse warping, this problem can be reduced (interpolation) But it is not always possible to get an invertible warp function Image Blending Most of the formulas are not importantblend two images togetherJust for knowledge Feathering Effect of window size Alpha Blending [IMPORTANT] Pyramid Blending Step Summary: Form two Gaussian Pyramids from 2 images Generate their Laplacian Pyramids LA and LB Construct a new Pyramid LS from LA and LB by combining the left half of LA and the right half of LB Reconstruct the blended image from the new Pyramid LS Detailed Steps: Forming a Gaussian Pyramid Start with the original image \\(G_0\\) Perform a Gaussian filtering about each pixel, down sampling so that the result is a reduced image of half the size in each dimension. Do this all the way up the pyramid. \\(G_I = REDUCE(G_{i-1})\\) Making the Laplacians Subtract each level of the pyramid from the next lower one Perform an interpolation process to do the subtraction because of different sizes in different levels. Interpolate new samples between those of a given image to make it big enough to subtract. The operation is called EXPAND gaussian pyramid Forming the New Pyramid Laplacian pyramids LA and LB are constructed for images A and B, respectively. A third Laplacian pyramid LS is constructed by copying nodes from the left half of LA to the corresponding nodes of LS and nodes from the right half of LB to the right half of LS. Nodes along the center line are set equal to the average of corresponding LA and LB nodes Using the New Laplacian Pyramid Use the new Laplacian pyramid with the reverse of how it was created to create a Gaussian pyramid. \\(G_i = L_i + expand(G_{i+1})\\) The lowest level gives the result 完整过程图示 [NOT IMPORTANT] Multiband Blending Decompose the image into multi-band frequency Blend each band appropriately At low frequencies, blend slowly Image regions that are “smooth” At high frequencies, blend quickly Image regions have a lot of pixel intensity variation Steps: Compute Laplacian pyramid of images and mask. Create blended image at each level of pyramid. Reconstruct complete image. [IMPORTANT] Recognizing Panoramas Steps: Extract SIFT points, descriptors from all images Find K-nearest neighbors for each point (K=4) For each image Select M candidate matching images by counting matched keypoints (M=6) Solve homography \\(H_{ij}\\) for each matched image Decide if match is valid \\((n_i &gt; 8 + 0.3 n_f)\\) Then we have matched pairs of images Make a graph of matched pairs to find connected components of the graph For each connected component Solve for rotation and f (camera parameters) Project to a surface (plane, cylinder, or sphere) Render with multiband blending","link":"/wiki/Lecture%20Note/COMP3065%20Computer%20Vision/CV4/"}],"tags":[{"name":"ECE560","slug":"ECE560","link":"/tags/ECE560/"},{"name":"welcome","slug":"welcome","link":"/tags/welcome/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Screen","slug":"Screen","link":"/tags/Screen/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"CICD","slug":"CICD","link":"/tags/CICD/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"},{"name":"Distributed System","slug":"Distributed-System","link":"/tags/Distributed-System/"},{"name":"COMP3052 Computer Security","slug":"COMP3052-Computer-Security","link":"/tags/COMP3052-Computer-Security/"},{"name":"COMP3056 Computer Vision","slug":"COMP3056-Computer-Vision","link":"/tags/COMP3056-Computer-Vision/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"C++ Multithreading","slug":"C-Multithreading","link":"/tags/C-Multithreading/"},{"name":"C++ singleton","slug":"C-singleton","link":"/tags/C-singleton/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Tencent","slug":"Tencent","link":"/tags/Tencent/"}],"categories":[{"name":"ECE560","slug":"ECE560","link":"/categories/ECE560/"},{"name":"Cloud-Native","slug":"Cloud-Native","link":"/categories/Cloud-Native/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"环境配置","slug":"环境配置","link":"/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"名校课程","slug":"名校课程","link":"/categories/%E5%90%8D%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"COMP3052 Computer Security","slug":"COMP3052-Computer-Security","link":"/categories/COMP3052-Computer-Security/"},{"name":"COMP3056 Computer Vision","slug":"COMP3056-Computer-Vision","link":"/categories/COMP3056-Computer-Vision/"},{"name":"Programming Languages","slug":"Programming-Languages","link":"/categories/Programming-Languages/"},{"name":"OA","slug":"OA","link":"/categories/OA/"}],"pages":[{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"About myself","text":"I grew up in Huzhou, Zhejiang, China. Before embarking my journey at Duke University, I received my bachelor degree in computer science at University of Nottingham (China Campus). In my spare time, I like watching TV dramas, listening to music, studying foreign languages (Japanese), and playing games (Apex Legend and Valorant) The purpose of establishing this website is mainly for recording and sharing knowledge wiki, as I found it quite important for computer science/engineering study. Recording a wiki is essential as artificial knowledge produced by human (computer programs obviously) is easy to forget. Feel free to contact me at tragicmaster@outlook.com if you have any queries. Thank you. Tragic Master 2023.1.1","link":"/about/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}]}